<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Hibernate入门系列（四） | Codegitz&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hibernate入门系列（四）映射映射一对多关联关系在领域模型中, 类与类之间最普遍的关系就是关联关系. 在 UML 中, 关联是有方向的. 以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联单向关联  双向关联  单向 n-1单向">
<meta name="keywords" content="Hibernate">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate入门系列（四）">
<meta property="og:url" content="http://yoursite.com/2017/06/30/Hibernate入门系列（四）/index.html">
<meta property="og:site_name" content="Codegitz&#39;s Blog">
<meta property="og:description" content="Hibernate入门系列（四）映射映射一对多关联关系在领域模型中, 类与类之间最普遍的关系就是关联关系. 在 UML 中, 关联是有方向的. 以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联单向关联  双向关联  单向 n-1单向">
<meta property="og:image" content="https://i.imgur.com/RcBWePb.png">
<meta property="og:image" content="https://i.imgur.com/V9XYGJw.png">
<meta property="og:image" content="https://i.imgur.com/9rAt2m2.png">
<meta property="og:image" content="https://i.imgur.com/CaydOhI.png">
<meta property="og:image" content="https://i.imgur.com/g7vkobq.png">
<meta property="og:image" content="https://i.imgur.com/UlbjSpR.png">
<meta property="og:image" content="https://i.imgur.com/zku0VBO.png">
<meta property="og:image" content="https://i.imgur.com/84VRUWl.png">
<meta property="og:image" content="https://i.imgur.com/VqNOd1L.png">
<meta property="og:image" content="https://i.imgur.com/5yfxMXp.png">
<meta property="og:image" content="https://i.imgur.com/TyscoD5.png">
<meta property="og:image" content="https://i.imgur.com/TjSFnAK.png">
<meta property="og:image" content="https://i.imgur.com/6hFCg9i.png">
<meta property="og:image" content="https://i.imgur.com/COpWyLF.png">
<meta property="og:image" content="https://i.imgur.com/VQaCib9.png">
<meta property="og:image" content="https://i.imgur.com/AXArowf.png">
<meta property="og:image" content="https://i.imgur.com/sIOuGr2.png">
<meta property="og:image" content="https://i.imgur.com/EFzJ7DM.png">
<meta property="og:image" content="https://i.imgur.com/CbOJU4l.png">
<meta property="og:image" content="https://i.imgur.com/NuVLIWd.png">
<meta property="og:image" content="https://i.imgur.com/cVdYs1A.png">
<meta property="og:image" content="https://i.imgur.com/pE38vZK.png">
<meta property="og:image" content="https://i.imgur.com/SRnzqGX.png">
<meta property="og:image" content="https://i.imgur.com/0LRRBLu.png">
<meta property="og:image" content="https://i.imgur.com/bxRPyAf.png">
<meta property="og:updated_time" content="2018-09-11T16:04:16.788Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hibernate入门系列（四）">
<meta name="twitter:description" content="Hibernate入门系列（四）映射映射一对多关联关系在领域模型中, 类与类之间最普遍的关系就是关联关系. 在 UML 中, 关联是有方向的. 以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联单向关联  双向关联  单向 n-1单向">
<meta name="twitter:image" content="https://i.imgur.com/RcBWePb.png">
  
    <link rel="alternate" href="/atom.xml" title="Codegitz&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://raw.githubusercontent.com/codegitz/TestCapacity/7acf45f27b3185ef97e94f69889d4c0253b12723/a5ea21%5B1%5D.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Codegitz</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/home">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/home">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Hibernate入门系列（四）</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://raw.githubusercontent.com/codegitz/MarkdownPhotos/master/Img8049893_f.jpg">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> Codegitz</span>
                <span class="post-date sub-title">at: 2017-06-30</span>
            </div>
            
                <div>
                    
                         <a class="tag is-post-tag" href="/tags/Hibernate/">Hibernate</a>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <script src="/assets/js/APlayer.min.js"> </script><h1 id="Hibernate入门系列（四）"><a href="#Hibernate入门系列（四）" class="headerlink" title="Hibernate入门系列（四）"></a>Hibernate入门系列（四）</h1><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="映射一对多关联关系"><a href="#映射一对多关联关系" class="headerlink" title="映射一对多关联关系"></a>映射一对多关联关系</h3><p>在领域模型中, 类与类之间最普遍的关系就是关联关系. <br><br>在 UML 中, 关联是有方向的. <br><br>以 Customer 和 Order 为例： 一个用户能发出多个订单, 而一个订单只能属于一个客户. 从 Order 到 Customer 的关联是多对一关联; 而从 Customer 到 Order 是一对多关联<br><br>单向关联<br></p>
<p><img src="https://i.imgur.com/RcBWePb.png" alt=""></p>
<p>双向关联<br></p>
<p><img src="https://i.imgur.com/V9XYGJw.png" alt=""></p>
<h4 id="单向-n-1"><a href="#单向-n-1" class="headerlink" title="单向 n-1"></a>单向 n-1</h4><p>单向 n-1 关联只需从 n 的一端可以访问 1 的一端<br><br>域模型: 从 Order 到 Customer 的多对一单向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中无需定义存放 Order 对象的集合属性<br></p>
<p><img src="https://i.imgur.com/9rAt2m2.png" alt=""></p>
<p>关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键<br><br><img src="https://i.imgur.com/CaydOhI.png" alt=""></p>
<p>显然无法直接用 property 映射 customer 属性<br><br>Hibernate 使用 <many-to-one> 元素来映射多对一关联关系<br></many-to-one></p>
<p>映射多对一的关联关系,使用many-to-one来映射多对一的关联关系<br>name：多这一端关联着一那一端的属性的名字<br><br>class：一那一端对应的属性的类名<br><br>column：一那一端在多那一端对应的数据表中的外键的名字 <br>  </p>
<pre><code>&lt;many-to-one name=&quot;customer&quot; class=&quot;io.hibernate.entities.n21.Customer&quot; column=&quot;CUSTOMER_ID&quot;&gt;
&lt;/many-to-one&gt;
</code></pre><p><strong>many-to-one</strong></p>
<p><many-to-one> 元素来映射组成关系<br><br>name: 设定待映射的持久化类的属性的名字<br><br>column: 设定和持久化类的属性对应的表的外键<br><br>class：设定待映射的持久化类的属性的类型<br></many-to-one></p>
<h4 id="双向-1-n"><a href="#双向-1-n" class="headerlink" title="双向 1-n"></a>双向 1-n</h4><p>双向 1-n 与 双向 n-1 是完全相同的两种情形<br><br>双向 1-n 需要在 1 的一端可以访问 n 的一端, 反之依然.<br><br>域模型:从 Order 到 Customer 的多对一双向关联需要在Order 类中定义一个 Customer 属性, 而在 Customer 类中需定义存放 Order 对象的集合属性<br></p>
<p><img src="https://i.imgur.com/g7vkobq.png" alt=""></p>
<p>关系数据模型:ORDERS 表中的 CUSTOMER_ID 参照 CUSTOMER 表的主键<br></p>
<p><img src="https://i.imgur.com/UlbjSpR.png" alt=""></p>
<p>当 Session 从数据库中加载 Java 集合时, 创建的是 Hibernate 内置集合类的实例, 因此在持久化类中定义集合属性时必须把属性声明为 Java 接口类型<br></p>
<ul>
<li>Hibernate 的内置集合类具有集合代理功能, 支持延迟检索策略<br></li>
<li><p>事实上, Hibernate 的内置集合类封装了 JDK 中的集合类, 这使得 Hibernate 能够对缓存中的集合对象进行脏检查, 按照集合对象的状态来同步更新数据库。<br><br>在定义集合属性时, 通常把它初始化为集合实现类的一个实例. 这样可以提高程序的健壮性, 避免应用程序访问取值为 null 的集合的方法抛出 <strong>NullPointerException</strong><br></p>
<pre><code>/*
 * 1.声明集合类型时需要使用接口类型，因为hibernate在获取集合类型时，返回的是
 * hibernate的内置集合类型，而不是JAVASE一个标准的集合实现
 * 2.需要对集合进行初始化，不会出现空指针异常的问题
 */
private Set&lt;Order&gt; orders=new HashSet&lt;&gt;();
</code></pre></li>
</ul>
<p>Hibernate 使用 <set> 元素来映射 set 类型的属性<br><br>映射关系如下：</set></p>
<pre><code>&lt;!-- 映射一对多的集合属性 --&gt;
  &lt;!-- set：映射set类型的属性，table：set中的元素对应的记录放在哪个数据表中，该值需要和多对一的那个多的表的名字一致 --&gt;
  &lt;!-- inverse：指定由哪一方来维护关联关系，通常设置为true，来指定由多的一方来维护关联关系 --&gt;
  &lt;!-- cascade:设定级联操作,开发时不建议设定该属性，建议使用手工的方式来处理 --&gt;
  &lt;!-- order-by:在查询时对集合中的元素进行排序，order-by中使用的是表的字段名，而非持久化类的属性名 --&gt;
  &lt;set name=&quot;orders&quot; table=&quot;ORDERS&quot; inverse=&quot;true&quot; cascade=&quot;delete-orphan&quot; order-by=&quot;&quot;&gt;
  &lt;!-- 执行对的表的外键列的名称 --&gt;
      &lt;key column=&quot;CUSTOMER_ID&quot;&gt;&lt;/key&gt;
      &lt;!-- 指定映射类型 --&gt;
      &lt;one-to-many class=&quot;io.hibernate.entities.n21.both.Order&quot;/&gt;
  &lt;/set&gt;
</code></pre><p><strong>各节点的含义：</strong></p>
<p><set> 元素来映射持久化类的 set 类型的属性<br><br>name: 设定待映射的持久化类的属性的<br></set></p>
<p><key> 元素设定与所关联的持久化类对应的表的外键<br><br>column: 指定关联表的外键名<br></key></p>
<p><one-to-many> 元素设定集合属性中所关联的持久化类<br><br>class: 指定关联的持久化类的类名<br><br><img src="https://i.imgur.com/zku0VBO.png" alt=""></one-to-many></p>
<p>inverse 属性</p>
<ul>
<li>在hibernate中通过对 inverse 属性的来决定是由双向关联的哪一方来维护表和表之间的关系. inverse = false 的为主动方，inverse = true 的为被动方, 由主动方负责维护关联关系<br></li>
<li>在没有设置 inverse=true 的情况下，父子两边都维护父子<br>关系 <br></li>
<li>在 1-n 关系中，将 n 方设为主控方将有助于性能改善(如果要国家元首记住全国人民的名字，不是太可能，但要让全国人民知道国家元首，就容易的多)<br></li>
<li>在 1-N 关系中，若将 1 方设为主控方<br><br>1.会额外多出 update 语句。<br><br>2.插入数据时无法同时插入外键列，因而无法为外键列添加非空约束<br><br>cascade 属性<br>在对象 – 关系映射文件中, 用于映射持久化类之间关联关系的元素, <set>, <many-to-one> 和 <one-to-one> 都有一个 cascade 属性, 它用于指定如何操纵与当前对象关联的其他对象.<br><img src="https://i.imgur.com/84VRUWl.png" alt=""><br>order-by 属性方<br><br><set> 元素有一个 order-by 属性, 如果设置了该属性, 当 Hibernate 通过 select 语句到数据库中检索集合对象时, 利用 order by 子句进行排序方<br><br>order-by 属性中还可以加入 SQL 函数方<br></set></one-to-one></many-to-one></set></li>
</ul>
<h3 id="映射一对一关联关系"><a href="#映射一对一关联关系" class="headerlink" title="映射一对一关联关系"></a>映射一对一关联关系</h3><p>1.域模型</p>
<p><img src="https://i.imgur.com/VqNOd1L.png" alt=""></p>
<p>2.关系数据模型</p>
<p>按照外键映射:</p>
<p><img src="https://i.imgur.com/5yfxMXp.png" alt=""></p>
<p>按照主键映射:</p>
<p><img src="https://i.imgur.com/TyscoD5.png" alt=""></p>
<h4 id="基于外键映射的-1-1"><a href="#基于外键映射的-1-1" class="headerlink" title="基于外键映射的 1-1"></a>基于外键映射的 1-1</h4><p>对于基于外键的1-1关联，其外键可以存放在任意一边，在需要存放外键一端，增加many-to-one元素。为many-to-one元素增加unique=“true” 属性来表示为1-1关联</p>
<pre><code>&lt;!-- 使用many-to-one方式来映射1-1关联关系 --&gt;
         &lt;many-to-one name=&quot;mgr&quot; class=&quot;io.hibernate.entities.Manager&quot; column=&quot;MGR_ID&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt;
</code></pre><p>另一端需要使用one-to-one元素，该元素使用 property-ref 属性指定使用被关联实体主键以外的字段作为关联字段</p>
<pre><code>&lt;!--  映射1—1关联关系，在对应数据表中已经有外键了，当前持久化类使用one-to-one进行映射--&gt;
       &lt;!-- 
            没有外键的一端需要使用one-to-one元素，该元素使用 property-ref 属性指定使用被关联实体主键以外的字段作为关联字段
       --&gt;
       &lt;one-to-one name=&quot;dept&quot; class=&quot;io.hibernate.entities.Department&quot;
        property-ref=&quot;mgr&quot;&gt;&lt;/one-to-one&gt;
</code></pre><p>不使用 property-ref 属性的 sql</p>
<pre><code>Hibernate: 
            select
                manager0_.MGR_ID as MGR_ID1_1_1_,
                manager0_.MGR_NAME as MGR_NAME2_1_1_,
                department1_.DEPT_ID as DEPT_ID1_0_0_,
                department1_.DEPT_NAME as DEPT_NAM2_0_0_,
                department1_.MGR_ID as MGR_ID3_0_0_ 
            from
                MANAGERS manager0_ 
            left outer join
                DEPARTMENTS department1_ 
                    on manager0_.MGR_ID=department1_.DEPT_ID //明显有误
            where
                manager0_.MGR_ID=?
</code></pre><p>使用 property-ref 属性的 sql</p>
<pre><code>Hibernate: 
    select
        manager0_.MGR_ID as MGR_ID1_1_1_,
        manager0_.MGR_NAME as MGR_NAME2_1_1_,
        department1_.DEPT_ID as DEPT_ID1_0_0_,
        department1_.DEPT_NAME as DEPT_NAM2_0_0_,
        department1_.MGR_ID as MGR_ID3_0_0_ 
    from
        MANAGERS manager0_ 
    left outer join
        DEPARTMENTS department1_ 
            on manager0_.MGR_ID=department1_.MGR_ID //正确
    where
        manager0_.MGR_ID=?
</code></pre><p>两边都使用外键映射的 1-1<br><br>此应用方式会导致引用之间不一一对应，从而产生引用混乱的情况,一般不会这样使用。<br><br><img src="https://i.imgur.com/TjSFnAK.png" alt=""></p>
<h4 id="基于主键映射的-1-1"><a href="#基于主键映射的-1-1" class="headerlink" title="基于主键映射的 1-1"></a>基于主键映射的 1-1</h4><p>基于主键的映射策略:指一端的主键生成器使用 foreign 策略,表明根据”对方”的主键来生成自己的主键，自己并不能独立生成主键. <param> 子元素指定使用当前持久化类的哪个属性作为 “对方”<br><br>采用foreign主键生成器策略的一端增加 one-to-one 元素映射关联属性，其one-to-one属性还应增加 constrained=“true” 属性；另一端增加one-to-one元素映射关联属性。<br><br>constrained(约束):指定为当前持久化类对应的数据库表的主键添加一个外键约束，引用被关联的对象(“对方”)所对应的数据库表主键<br></p>
<h3 id="映射多对多关联关系"><a href="#映射多对多关联关系" class="headerlink" title="映射多对多关联关系"></a>映射多对多关联关系</h3><h4 id="单向-n-n"><a href="#单向-n-n" class="headerlink" title="单向 n-n"></a>单向 n-n</h4><p>域模型: <br></p>
<p><img src="https://i.imgur.com/6hFCg9i.png" alt=""></p>
<p>关系数据模型:<br></p>
<p><img src="https://i.imgur.com/COpWyLF.png" alt=""></p>
<p><strong>n-n 的关联必须使用连接表</strong><br><br>与 1-n 映射类似，必须为 set 集合元素添加 key 子元素，指定 CATEGORIES_ITEMS 表中参照 CATEGORIES 表的外键为 CATEGORIY_ID. 与 1-n 关联映射不同的是，建立 n-n 关联时, 集合中的元素使用 many-to-many. many-to-many 子元素的 class 属性指定 items 集合中存放的是 Item 对象, column 属性指定  CATEGORIES_ITEMS 表中参照 ITEMS 表的外键为 ITEM_ID<br></p>
<p><img src="https://i.imgur.com/VQaCib9.png" alt=""><br><img src="https://i.imgur.com/AXArowf.png" alt=""></p>
<h4 id="双向-n-n"><a href="#双向-n-n" class="headerlink" title="双向 n-n"></a>双向 n-n</h4><p>域模型: </p>
<p><img src="https://i.imgur.com/sIOuGr2.png" alt=""></p>
<p>关系数据模型:</p>
<p><img src="https://i.imgur.com/EFzJ7DM.png" alt=""></p>
<p>双向 n-n 关联需要两端都使用集合属性<br><br>双向n-n关联必须使用连接表<br><br>集合属性应增加 key 子元素用以映射外键列, 集合元素里还应增加many-to-many子元素关联实体类<br><br>在双向 n-n 关联的两边都需指定连接表的表名及外键列的列名. 两个集合元素 set 的 table 元素的值必须指定，而且必须相同。set元素的两个子元素：key 和 many-to-many 都必须指定 column 属性，其中，key 和 many-to-many 分别指定本持久化类和关联类在连接表中的外键列名，因此两边的 key 与 many-to-many 的column属性交叉相同。也就是说，一边的set元素的key的 cloumn值为a,many-to-many 的 column 为b；则另一边的 set 元素的 key 的 column 值 b,many-to-many的 column 值为 a.  <br><br>对于双向 n-n 关联, 必须把其中一端的 inverse 设置为 true, 否则两端都维护关联关系可能会造成主键冲突.<br></p>
<p><img src="https://i.imgur.com/CbOJU4l.png" alt=""></p>
<h3 id="映射继承关系"><a href="#映射继承关系" class="headerlink" title="映射继承关系"></a>映射继承关系</h3><p>对于面向对象的程序设计语言而言，继承和多态是两个最基本的概念。Hibernate 的继承映射可以理解持久化类之间的继承关系。例如：人和学生之间的关系。学生继承了人，可以认为学生是一个特殊的人，如果对人进行查询，学生的实例也将被得到。<br><br><img src="https://i.imgur.com/NuVLIWd.png" alt=""></p>
<p>Hibernate支持三种继承映射策略：<br></p>
<ul>
<li>使用 subclass 进行映射：将域模型中的每一个实体对象映射到一个独立的表中，也就是说不用在关系数据模型中考虑域模型中的继承关系和多态。 <br></li>
<li>使用 joined-subclass 进行映射： 对于继承关系中的子类使用同一个表，这就需要在数据库表中增加额外的区分子类类型的字段。 <br></li>
<li>使用 union-subclass 进行映射：域模型中的每个类映射到一个表，通过关系数据模型中的外键来描述表之间的继承关系。这也就相当于按照域模型的结构来建立数据库中的表，并通过外键来建立表之间的继承关系。<br></li>
</ul>
<h4 id="采用-subclass-元素的继承映射"><a href="#采用-subclass-元素的继承映射" class="headerlink" title="采用 subclass 元素的继承映射"></a>采用 subclass 元素的继承映射</h4><p>采用 subclass 的继承映射可以实现对于继承关系中父类和子类使用同一张表<br><br>因为父类和子类的实例全部保存在同一个表中，因此需要在该表内增加一列，使用该列来区分每行记录到低是哪个类的实例—-这个列被称为辨别者列(discriminator).<br><br>在这种映射策略下，使用 subclass 来映射子类，使用 class 或 subclass 的 discriminator-value 属性指定辨别者列的值<br><br>所有子类定义的字段都不能有非空约束。如果为那些字段添加非空约束，那么父类的实例在那些列其实并没有值，这将引起数据库完整性冲突，导致父类的实例无法保存到数据库中<br><br><img src="https://i.imgur.com/cVdYs1A.png" alt=""></p>
<pre><code>&lt;class name=&quot;io.hibernate.entities.subclass.Person&quot; table=&quot;PERSONS&quot; discriminator-value=&quot;PERSON&quot;&gt;
        &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
            &lt;column name=&quot;ID&quot; /&gt;
            &lt;generator class=&quot;native&quot; /&gt;
        &lt;/id&gt;
        &lt;!--  配置辨别者列--&gt;
        &lt;discriminator column=&quot;TYPE&quot; type=&quot;string&quot;&gt;&lt;/discriminator&gt;

        &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
            &lt;column name=&quot;NAME&quot; /&gt;
        &lt;/property&gt;
        &lt;property name=&quot;age&quot; type=&quot;int&quot;&gt;
            &lt;column name=&quot;AGE&quot; /&gt;
        &lt;/property&gt;
        &lt;!-- 映射子类student，使用subclass进行映射 --&gt;
        &lt;subclass name=&quot;io.hibernate.entities.subclass.Student&quot; discriminator-value=&quot;STUDENT&quot;&gt;
             &lt;property name=&quot;school&quot; type=&quot;string&quot; column=&quot;SCHOOL&quot;&gt;&lt;/property&gt;
        &lt;/subclass&gt;
    &lt;/class&gt;
</code></pre><h4 id="采用-joined-subclass-元素的继承映射"><a href="#采用-joined-subclass-元素的继承映射" class="headerlink" title="采用 joined-subclass 元素的继承映射"></a>采用 joined-subclass 元素的继承映射</h4><p>采用 joined-subclass 元素的继承映射可以实现每个子类一张表<br><br>采用这种映射策略时，父类实例保存在父类表中，子类实例由父类表和子类表共同存储。因为子类实例也是一个特殊的父类实例，因此必然也包含了父类实例的属性。于是将子类和父类共有的属性保存在父类表中，子类增加的属性，则保存在子类表中。<br><br>在这种映射策略下，无须使用鉴别者列，但需要为每个子类使用 key 元素映射共有主键。<br><br>子类增加的属性可以添加非空约束。因为子类的属性和父类的属性没有保存在同一个表中<br><br><img src="https://i.imgur.com/pE38vZK.png" alt=""></p>
<pre><code>&lt;class name=&quot;io.hibernate.entities.joined.subclass.Person&quot; table=&quot;PERSONS&quot;&gt;
       &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
           &lt;column name=&quot;ID&quot; /&gt;
           &lt;generator class=&quot;native&quot; /&gt;
       &lt;/id&gt;
       &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
           &lt;column name=&quot;NAME&quot; /&gt;
       &lt;/property&gt;
       &lt;property name=&quot;age&quot; type=&quot;int&quot;&gt;
           &lt;column name=&quot;AGE&quot; /&gt;
       &lt;/property&gt;
       &lt;joined-subclass name=&quot;io.hibernate.entities.joined.subclass.Student&quot; table=&quot;STUDENTS&quot;&gt;
             &lt;key column=&quot;STUDENT_id&quot;&gt;&lt;/key&gt;
             &lt;property name=&quot;school&quot; type=&quot;string&quot; column=&quot;SCHOOL&quot;&gt;&lt;/property&gt;
       &lt;/joined-subclass&gt;
   &lt;/class&gt;
</code></pre><h4 id="采用-union-subclass-元素的继承映射"><a href="#采用-union-subclass-元素的继承映射" class="headerlink" title="采用 union-subclass 元素的继承映射"></a>采用 union-subclass 元素的继承映射</h4><p><img src="https://i.imgur.com/SRnzqGX.png" alt=""></p>
<pre><code>&lt;class name=&quot;io.hibernate.entities.joined.subclass.Person&quot; table=&quot;PERSONS&quot;&gt;
           &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt;
               &lt;column name=&quot;ID&quot; /&gt;
               &lt;generator class=&quot;increment&quot; /&gt;
           &lt;/id&gt;
           &lt;property name=&quot;name&quot; type=&quot;java.lang.String&quot;&gt;
               &lt;column name=&quot;NAME&quot; /&gt;
           &lt;/property&gt;
           &lt;property name=&quot;age&quot; type=&quot;int&quot;&gt;
               &lt;column name=&quot;AGE&quot; /&gt;
           &lt;/property&gt;
           &lt;union-subclass name=&quot;io.hibernate.entities.joined.subclass.Student&quot; table=&quot;STUDENTS&quot;&gt;
                 &lt;property name=&quot;school&quot;&gt;&lt;/property&gt;
           &lt;/union-subclass&gt;
       &lt;/class&gt;
</code></pre><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p><img src="https://i.imgur.com/0LRRBLu.png" alt=""></p>
<p><img src="https://i.imgur.com/bxRPyAf.png" alt=""></p>

        </div>
        <div class="post-reply">
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Theme by <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © Codegitz 2018
        <br>
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>