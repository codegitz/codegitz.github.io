<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Hibernate入门系列（五） | Codegitz&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hibernate入门系列（五）Hibernate 检索策略检索数据时的 2 个问题：不浪费内存：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存.更高的查询效率：发送尽可能少的 SQL 语句 类级别的检索策略类级别可选的检索策略">
<meta name="keywords" content="Hibernate">
<meta property="og:type" content="article">
<meta property="og:title" content="Hibernate入门系列（五）">
<meta property="og:url" content="http://yoursite.com/2017/06/30/Hibernate入门系列（五）/index.html">
<meta property="og:site_name" content="Codegitz&#39;s Blog">
<meta property="og:description" content="Hibernate入门系列（五）Hibernate 检索策略检索数据时的 2 个问题：不浪费内存：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存.更高的查询效率：发送尽可能少的 SQL 语句 类级别的检索策略类级别可选的检索策略">
<meta property="og:image" content="https://i.imgur.com/rcMQ103.png">
<meta property="og:image" content="https://i.imgur.com/O98iEuD.png">
<meta property="og:image" content="https://i.imgur.com/cIGByXK.png">
<meta property="og:image" content="https://i.imgur.com/r32YY7j.png">
<meta property="og:image" content="https://i.imgur.com/GjPwINY.png">
<meta property="og:image" content="https://i.imgur.com/TwOhbnU.png">
<meta property="og:image" content="https://i.imgur.com/llBlsGE.png">
<meta property="og:image" content="https://i.imgur.com/8QnBa4G.png">
<meta property="og:image" content="https://i.imgur.com/YQ4crb1.png">
<meta property="og:image" content="https://i.imgur.com/3jutCzp.png">
<meta property="og:updated_time" content="2018-09-11T16:04:08.908Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hibernate入门系列（五）">
<meta name="twitter:description" content="Hibernate入门系列（五）Hibernate 检索策略检索数据时的 2 个问题：不浪费内存：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存.更高的查询效率：发送尽可能少的 SQL 语句 类级别的检索策略类级别可选的检索策略">
<meta name="twitter:image" content="https://i.imgur.com/rcMQ103.png">
  
    <link rel="alternate" href="/atom.xml" title="Codegitz&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://raw.githubusercontent.com/codegitz/TestCapacity/7acf45f27b3185ef97e94f69889d4c0253b12723/a5ea21%5B1%5D.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Codegitz</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/home">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/home">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>Hibernate入门系列（五）</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://raw.githubusercontent.com/codegitz/MarkdownPhotos/master/Img8049893_f.jpg">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> Codegitz</span>
                <span class="post-date sub-title">at: 2017-06-30</span>
            </div>
            
                <div>
                    
                         <a class="tag is-post-tag" href="/tags/Hibernate/">Hibernate</a>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <script src="/assets/js/APlayer.min.js"> </script><h1 id="Hibernate入门系列（五）"><a href="#Hibernate入门系列（五）" class="headerlink" title="Hibernate入门系列（五）"></a>Hibernate入门系列（五）</h1><h2 id="Hibernate-检索策略"><a href="#Hibernate-检索策略" class="headerlink" title="Hibernate 检索策略"></a>Hibernate 检索策略</h2><p>检索数据时的 2 个问题：<br><br>不浪费内存：当 Hibernate 从数据库中加载 Customer 对象时, 如果同时加载所有关联的 Order 对象, 而程序实际上仅仅需要访问 Customer 对象, 那么这些关联的 Order 对象就白白浪费了许多内存.<br><br>更高的查询效率：发送尽可能少的 SQL 语句<br><img src="https://i.imgur.com/rcMQ103.png" alt=""></p>
<h3 id="类级别的检索策略"><a href="#类级别的检索策略" class="headerlink" title="类级别的检索策略"></a>类级别的检索策略</h3><p>类级别可选的检索策略包括立即检索和延迟检索, 默认为延迟检索<br><br>立即检索: 立即加载检索方法指定的对象<br><br>延迟检索: 延迟加载检索方法指定的对象。在使用具体的属性时，再进行加载<br><br>类级别的检索策略可以通过 <class> 元素的 lazy 属性进行设置<br><br>如果程序加载一个对象的目的是为了访问它的属性, 可以采取立即检索.<br><br>如果程序加载一个持久化对象的目的是仅仅为了获得它的引用, 可以采用延迟检索。注意出现懒加载异常！<br><br>无论 <class> 元素的 lazy 属性是 true 还是 false, Session 的 get() 方法及 Query 的 list() 方法在类级别总是使用立即检索策略<br><br>若 <class> 元素的 lazy 属性为 true 或取默认值, Session 的 load() 方法不会执行查询数据表的 SELECT 语句, 仅返回代理类对象的实例, 该代理类实例有如下特征:<br><br>由 Hibernate 在运行时采用 CGLIB 工具动态生成<br><br>Hibernate 创建代理类实例时, 仅初始化其 OID 属性<br><br>在应用程序第一次访问代理类实例的非 OID 属性时, Hibernate 会初始化代理类实例<br></class></class></class></p>
<h3 id="一对多和多对多的检索策略"><a href="#一对多和多对多的检索策略" class="headerlink" title="一对多和多对多的检索策略"></a>一对多和多对多的检索策略</h3><p>在映射文件中, 用 <set> 元素来配置一对多关联及多对多关联关系.<br> <set> 元素有 lazy 和 fetch 属性<br><br>lazy: 主要决定 orders 集合被初始化的时机. 即到底是在加载 <br>Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化<br><br>fetch: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机<br><br>若把 fetch 设置为 “join”, lazy 属性将被忽略<br></set></set></p>
<p><set> 元素的 batch-size 属性：用来为延迟检索策略或立即检索策略设定批量检索的数量. 批量检索能减少 SELECT 语句的数目, 提高延迟检索或立即检索的运行性能.<br><br><strong><set> 元素的 lazy 和 fetch 属性</set></strong><br></set></p>
<p><img src="https://i.imgur.com/O98iEuD.png" alt=""></p>
<p><strong><set> 元素的 batch-size 属性</set></strong></p>
<p><set> 元素有一个 batch-size 属性, 用来为延迟检索策略或立即检索策略设定批量检索的数量. 批量检索能减少 SELECT 语句的数目, 提高延迟检索或立即检索的运行性能<br></set></p>
<p><strong>延迟检索和增强延迟检索</strong><br><br>在延迟检索(lazy 属性值为 true) 集合属性时, Hibernate 在以下情况下初始化集合代理类实例 <br><br>应用程序第一次访问集合属性: iterator(), size(), isEmpty(), contains() 等方法<br><br>通过 Hibernate.initialize() 静态方法显式初始化<br><br>增强延迟检索(lazy 属性为 extra): 与 lazy=“true” 类似. 主要区别是增强延迟检索策略能进一步延迟 Customer 对象的 orders 集合代理实例的初始化时机：<br><br>当程序第一次访问 orders 属性的 iterator() 方法时, 会导致 orders 集合代理类实例的初始化<br><br>当程序第一次访问 order 属性的 size(), contains() 和 isEmpty() 方法时, Hibernate 不会初始化 orders 集合类的实例, 仅通过特定的 select 语句查询必要的信息, 不会检索所有的 Order 对象<br></p>
<h3 id="多对一和一对一关联的检索策略"><a href="#多对一和一对一关联的检索策略" class="headerlink" title="多对一和一对一关联的检索策略"></a>多对一和一对一关联的检索策略</h3><p>在映射文件中, 用 <set> 元素来配置一对多关联及多对多关联关系. /br&gt;<set> 元素有 lazy 和 fetch 属性<br><br>lazy: 主要决定 orders 集合被初始化的时机. 即到底是在加载 Customer 对象时就被初始化, 还是在程序访问 orders 集合时被初始化<br><br>fetch: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机/br&gt;<br>若把 fetch 设置为 “join”, lazy 属性将被忽略<br><br><strong>用带子查询的 select 语句整批量初始化 orders 集合(fetch 属性为 “subselect”)</strong></set></set></p>
<p><set> 元素的 fetch 属性: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机.默认值为 select <br><br>当 fetch 属性为 “subselect” 时<br><br>假定 Session 缓存中有 n 个 orders 集合代理类实例没有被初始化, Hibernate 能够通过带子查询的 select 语句, 来批量初始化 n 个 orders 集合代理类实例<br>batch-size 属性将被忽略<br><br>子查询中的 select 语句为查询 CUSTOMERS 表 OID 的 SELECT 语句<br><br><strong>迫切左外连接检索(fetch 属性值设为 “join”)</strong></set></p>
<p><set> 元素的 fetch 属性: 取值为 “select” 或 “subselect” 时, 决定初始化 orders 的查询语句的形式;  若取值为”join”, 则决定 orders 集合被初始化的时机.默认值为 select <br><br>当 fetch 属性为 “join” 时:<br><br>检索 Customer 对象时, 会采用迫切左外连接(通过左外连接加载与检索指定的对象关联的对象)策略来检索所有关联的 Order 对象<br>lazy 属性将被忽略<br><br>Query 的list() 方法会忽略映射文件中配置的迫切左外连接检索策略, 而依旧采用延迟加载策略<br><br>和 <set> 一样, <many-to-one> 元素也有一个 lazy 属性和 fetch 属性.<br></many-to-one></set></set></p>
<p><img src="https://i.imgur.com/cIGByXK.png" alt=""></p>
<p>若 fetch 属性设为 join, 那么 lazy 属性被忽略<br><br>迫切左外连接检索策略的优点在于比立即检索策略使用的 SELECT 语句更少. <br><br>无代理延迟检索需要增强持久化类的字节码才能实现<br>Query 的 list 方法会忽略映射文件配置的迫切左外连接检索策略, 而采用延迟检索策略<br><br>如果在关联级别使用了延迟加载或立即加载检索策略, 可以设定批量检索的大小, 以帮助提高延迟检索或立即检索的运行性能. <br><br>Hibernate 允许在应用程序中覆盖映射文件中设定的检索策略<br></p>
<h3 id="检索策略小结"><a href="#检索策略小结" class="headerlink" title="检索策略小结"></a>检索策略小结</h3><p>类级别和关联级别可选的检索策略及默认的检索策略<br></p>
<p><img src="https://i.imgur.com/r32YY7j.png" alt=""></p>
<p>3 种检索策略的运行机制<br></p>
<p><img src="https://i.imgur.com/GjPwINY.png" alt=""></p>
<p>映射文件中用于设定检索策略的几个属性<br></p>
<p><img src="https://i.imgur.com/TwOhbnU.png" alt=""></p>
<p>比较 Hibernate 的三种检索策略<br><br><img src="https://i.imgur.com/llBlsGE.png" alt=""></p>
<h2 id="Hibernate-检索方式"><a href="#Hibernate-检索方式" class="headerlink" title="Hibernate 检索方式"></a>Hibernate 检索方式</h2><p>Hibernate 提供了以下几种检索对象的方式<br><br>导航对象图检索方式:  根据已经加载的对象导航到其他对象<br><br>OID 检索方式:  按照对象的 OID 来检索对象<br><br>HQL 检索方式: 使用面向对象的 HQL 查询语言<br><br>QBC 检索方式: 使用 QBC(Query By Criteria) API 来检索对象. 这种 API 封装了基于字符串形式的查询语句, 提供了更加面向对象的查询接口. <br><br>本地 SQL 检索方式: 使用本地数据库的 SQL 查询语句<br></p>
<h3 id="HQL-检索方式"><a href="#HQL-检索方式" class="headerlink" title="HQL 检索方式"></a>HQL 检索方式</h3><p>HQL(Hibernate Query Language) 是面向对象的查询语言, 它和 SQL 查询语言有些相似. 在 Hibernate 提供的各种检索方式中, HQL 是使用最广的一种检索方式. <br>它有如下功能:<br><br>在查询语句中设定各种查询条件<br><br>支持投影查询, 即仅检索出对象的部分属性<br><br>支持分页查询<br><br>支持连接查询<br><br>支持分组查询, 允许使用 HAVING 和 GROUP BY 关键字<br><br>提供内置聚集函数, 如 sum(), min() 和 max()<br><br>支持子查询<br><br>支持动态绑定参数<br><br>能够调用 用户定义的 SQL 函数或标准的 SQL 函数<br><br>HQL 检索方式包括以下步骤:<br><br>通过 Session 的 createQuery() 方法创建一个 Query 对象, 它包括一个 HQL 查询语句. HQL 查询语句中可以包含命名参数<br><br>动态绑定参数<br><br>调用 Query 相关方法执行查询语句. <br><br>Qurey 接口支持方法链编程风格, 它的 setXxx() 方法返回自身实例, 而不是 void 类型<br><br>HQL vs SQL:<br><br>HQL 查询语句是面向对象的, Hibernate 负责解析 HQL 查询语句, 然后根据对象-关系映射文件中的映射信息, 把 HQL 查询语句翻译成相应的 SQL 语句. HQL 查询语句中的主体是域模型中的类及类的属性<br>SQL 查询语句是与关系数据库绑定在一起的. SQL 查询语句中的主体是数据库表及表的字段. <br><br>绑定参数:<br><br>Hibernate 的参数绑定机制依赖于 JDBC API 中的 PreparedStatement 的预定义 SQL 语句功能.<br><br>HQL 的参数绑定由两种形式:<br><br>按参数名字绑定: 在 HQL 查询语句中定义命名参数, 命名参数以 “:” 开头.<br><br>按参数位置绑定: 在 HQL 查询语句中用 “?” 来定义参数位置<br><br>相关方法:<br><br>setEntity(): 把参数与一个持久化类绑定<br><br>setParameter(): 绑定任意类型的参数. 该方法的第三个参数显式指定 Hibernate 映射类型<br><br>HQL 采用 ORDER BY 关键字对查询结果排序<br><br>分页查询:<br><br>setFirstResult(int firstResult): 设定从哪一个对象开始检索, 参数 firstResult 表示这个对象在查询结果中的索引位置, 索引位置的起始值为 0. 默认情况下, Query 从查询结果中的第一个对象开始检索<br><br>setMaxResults(int maxResults): 设定一次最多检索出的对象的数目. 在默认情况下, Query 和 Criteria 接口检索出查询结果中所有的对象<br><br>在映射文件中定义命名查询语句<br>Hibernate 允许在映射文件中定义字符串形式的查询语句. <br><br><code>&lt;query&gt;</code> 元素用于定义一个 HQL 查询语句, 它和 <code>&lt;class&gt;</code>元素并列. <br><br>在程序中通过 Session 的 getNamedQuery() 方法获取查询语句对应的 Query 对象. <br></p>
<p><strong>投影查询</strong><br><br>投影查询: 查询结果仅包含实体的部分属性. 通过 SELECT 关键字实现.<br>Query 的 list() 方法返回的集合中包含的是数组类型的元素, 每个对象数组代表查询结果的一条记录<br><br>可以在持久化类中定义一个对象的构造器来包装投影查询返回的记录, 使程序代码能完全运用面向对象的语义来访问查询结果集. <br><br>可以通过 DISTINCT 关键字来保证查询结果不会返回重复元素<br><br><strong>报表查询</strong><br><br>报表查询用于对数据分组和统计, 与 SQL 一样, HQL 利用 GROUP BY 关键字对数据分组, 用 HAVING 关键字对分组数据设定约束条件.<br><br>在 HQL 查询语句中可以调用以下聚集函数<br><br>count()<br><br>min()<br><br>max()<br><br>sum()<br><br>avg()<br><br><strong>HQL (迫切)左外连接</strong><br><br>迫切左外连接:<br><br>LEFT JOIN FETCH 关键字表示迫切左外连接检索策略.<br><br>list() 方法返回的集合中存放实体对象的引用, 每个 Department 对象关联的 Employee  集合都被初始化, 存放所有关联的 Employee 的实体对象. <br><br>查询结果中可能会包含重复元素, 可以通过一个 HashSet 来过滤重复元素<br><br>左外连接:<br><br>LEFT JOIN 关键字表示左外连接查询. <br><br>list() 方法返回的集合中存放的是对象数组类型<br><br>根据配置文件来决定 Employee 集合的检索策略. <br><br>如果希望 list() 方法返回的集合中仅包含 Department 对象, 可以在HQL 查询语句中使用 SELECT 关键字<br><br><strong>HQL (迫切)内连接</strong><br><br>迫切内连接:<br><br>INNER JOIN FETCH 关键字表示迫切内连接, 也可以省略 INNER 关键字<br><br>list() 方法返回的集合中存放 Department 对象的引用, 每个 Department 对象的 Employee 集合都被初始化, 存放所有关联的 Employee 对象<br><br>内连接:<br><br>INNER JOIN 关键字表示内连接, 也可以省略 INNER 关键字<br><br>list() 方法的集合中存放的每个元素对应查询结果的一条记录, 每个元素都是对象数组类型<br><br>如果希望 list() 方法的返回的集合仅包含 Department  对象, 可以在 HQL 查询语句中使用 SELECT 关键字<br></p>
<h3 id="关联级别运行时的检索策略"><a href="#关联级别运行时的检索策略" class="headerlink" title="关联级别运行时的检索策略"></a>关联级别运行时的检索策略</h3><p>如果在 HQL 中没有显式指定检索策略, 将使用映射文件配置的检索策略. <br><br>HQL 会忽略映射文件中设置的迫切左外连接检索策略, 如果希望 HQL 采用迫切左外连接策略, 就必须在 HQL 查询语句中显式的指定它<br><br>若在 HQL 代码中显式指定了检索策略, 就会覆盖映射文件中配置的检索策略<br></p>
<h3 id="QBC-检索和本地-SQL-检索"><a href="#QBC-检索和本地-SQL-检索" class="headerlink" title="QBC 检索和本地 SQL 检索"></a>QBC 检索和本地 SQL 检索</h3><p>QBC 查询就是通过使用 Hibernate 提供的 Query By Criteria API 来查询对象，这种 API 封装了 SQL 语句的动态拼装，对查询提供了更加面向对象的功能接口<br><br>本地SQL查询来完善HQL不能涵盖所有的查询特性<br></p>
<h2 id="Hibernate-二级缓存"><a href="#Hibernate-二级缓存" class="headerlink" title="Hibernate 二级缓存"></a>Hibernate 二级缓存</h2><p>缓存(Cache): 计算机领域非常通用的概念。它介于应用程序和永久性数据存储源(如硬盘上的文件或者数据库)之间，其作用是降低应用程序直接读写永久性数据存储源的频率，从而提高应用的运行性能。缓存中的数据是数据存储源中数据的拷贝。缓存的物理介质通常是内存<br><br>Hibernate中提供了两个级别的缓存<br><br>第一级别的缓存是 Session 级别的缓存，它是属于事务范围的缓存。这一级别的缓存由 hibernate 管理的<br><br>第二级别的缓存是SessionFactory 级别的缓存，它是属于进程范围的缓存<br><br><strong>使用 Hibernate 的二级缓存</strong><br>适合放入二级缓存中的数据:<br><br>很少被修改<br><br>不是很重要的数据, 允许出现偶尔的并发问题<br><br>不适合放入二级缓存中的数据:<br><br>经常被修改<br><br>财务数据, 绝对不允许出现并发问题<br>与其他应用程序共享的数据<br></p>
<p><strong>Hibernate 二级缓存的架构</strong><br><img src="https://i.imgur.com/8QnBa4G.png" alt=""></p>
<h4 id="SessionFactory-级别的缓存"><a href="#SessionFactory-级别的缓存" class="headerlink" title="SessionFactory 级别的缓存"></a>SessionFactory 级别的缓存</h4><p>SessionFactory 的缓存可以分为两类:<br><br>内置缓存: Hibernate 自带的, 不可卸载. 通常在 Hibernate 的初始化阶段, Hibernate 会把映射元数据和预定义的 SQL 语句放到 SessionFactory 的缓存中, 映射元数据是映射文件中数据（.hbm.xml 文件中的数据）的复制. 该内置缓存是只读的. <br><br>外置缓存(二级缓存): 一个可配置的缓存插件. 在默认情况下, SessionFactory 不会启用这个缓存插件. 外置缓存中的数据是数据库数据的复制, 外置缓存的物理介质可以是内存或硬盘<br></p>
<h4 id="二级缓存的并发访问策略"><a href="#二级缓存的并发访问策略" class="headerlink" title="二级缓存的并发访问策略"></a>二级缓存的并发访问策略</h4><p>两个并发的事务同时访问持久层的缓存的相同数据时, 也有可能出现各类并发问题. <br><br>二级缓存可以设定以下 4 种类型的并发访问策略, 每一种访问策略对应一种事务隔离级别<br><br>非严格读写(Nonstrict-read-write): 不保证缓存与数据库中数据的一致性. 提供 Read Uncommited 事务隔离级别, 对于极少被修改, 而且允许脏读的数据, 可以采用这种策略<br><br>读写型(Read-write): 提供 Read Commited 数据隔离级别.对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读<br><br>事务型(Transactional): 仅在受管理环境下适用. 它提供了 Repeatable Read 事务隔离级别. 对于经常读但是很少被修改的数据, 可以采用这种隔离类型, 因为它可以防止脏读和不可重复读<br><br>只读型(Read-Only):提供 Serializable 数据隔离级别, 对于从来不会被修改的数据, 可以采用这种访问策略<br></p>
<h4 id="管理-Hibernate-的二级缓存"><a href="#管理-Hibernate-的二级缓存" class="headerlink" title="管理 Hibernate 的二级缓存"></a>管理 Hibernate 的二级缓存</h4><p>Hibernate 的二级缓存是进程或集群范围内的缓存<br><br>二级缓存是可配置的的插件, Hibernate 允许选用以下类型的缓存插件:<br><br>EHCache: 可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 对 Hibernate 的查询缓存提供了支持<br><br>OpenSymphony OSCache:可作为进程范围内的缓存, 存放数据的物理介质可以使内存或硬盘, 提供了丰富的缓存数据过期策略, 对 Hibernate 的查询缓存提供了支持<br><br>SwarmCache: 可作为集群范围内的缓存, 但不支持 Hibernate 的查询缓存<br><br>JBossCache:可作为集群范围内的缓存, 支持 Hibernate 的查询缓存<br><br>4 种缓存插件支持的并发访问策略(x 代表支持, 空白代表不支持)<br></p>
<p><img src="https://i.imgur.com/YQ4crb1.png" alt=""></p>
<h4 id="配置进程范围内的二级缓存"><a href="#配置进程范围内的二级缓存" class="headerlink" title="配置进程范围内的二级缓存"></a>配置进程范围内的二级缓存</h4><p>配置进程范围内的二级缓存的步骤: <br><br>选择合适的缓存插件: EHCache(jar 包和 配置文件), 并编译器配置文件<br><br>在 Hibernate 的配置文件中启用二级缓存并指定和 EHCache 对应的缓存适配器<br><br>选择需要使用二级缓存的持久化类, 设置它的二级缓存的并发访问策略<br></p>
<p><class> 元素的 cache 子元素表明 Hibernate 会缓存对象的简单属性, 但不会缓存集合属性, 若希望缓存集合属性中的元素, 必须在 <code>&lt;set&gt;</code> 元素中加入 <code>&lt;cache&gt;</code> 子元素<br><br>在 hibernate 配置文件中通过 <code>&lt;class-cache/&gt;</code> 节点配置使用缓存<br></class></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
    &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt;
    &lt;version&gt;2.4.3&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-ehcache&lt;/artifactId&gt;
    &lt;version&gt;4.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h4 id="ehcache-xml"><a href="#ehcache-xml" class="headerlink" title="ehcache.xml"></a>ehcache.xml</h4><p><diskstore>: 指定一个目录：当 EHCache 把数据写到硬盘上时, 将把数据写到这个目录下.<br></diskstore></p>
<p><defaultcache>: 设置缓存的默认数据过期策略 <br></defaultcache></p>
<p><cache> 设定具体的命名缓存的数据过期策略。每个命名缓存代表一个缓存区域<br><br>缓存区域(region)：一个具有名称的缓存块，可以给每一个缓存块设置不同的缓存策略。如果没有设置任何的缓存区域，则所有被缓存的对象，都将使用默认的缓存策略。即：<code>&lt;defaultCache.../&gt;</code><br>Hibernate在不同的缓存区域保存不同的类/集合。<br><br>对于类而言，区域的名称是类名。如:com.atguigu.domain.Customer<br><br>对于集合而言，区域的名称是类名加属性名。如com.atguigu.domain.Customer.orders<br><br>cache 元素的属性   <br><br>name:设置缓存的名字,它的取值为类的全限定名或类的集合的名字 <br><br>maxInMemory:设置基于内存的缓存中可存放的对象最大数目 <br><br>eternal:设置对象是否为永久的,true表示永不过期,此时将忽略timeToIdleSeconds 和 timeToLiveSeconds属性; 默认值是false <br><br>timeToIdleSeconds:设置对象空闲最长时间,以秒为单位, 超过这个时间,对象过期。当对象过期时,EHCache会把它从缓存中清除。如果此值为0,表示对象可以无限期地处于空闲状态。<br><br>timeToLiveSeconds:设置对象生存最长时间,超过这个时间,对象过期。如果此值为0,表示对象可以无限期地存在于缓存中. 该属性值必须大于或等于 timeToIdleSeconds 属性值 <br><br>overflowToDisk:设置基于内存的缓存中的对象数目达到上限后,是否把溢出的对象写到基于硬盘的缓存中 <br></cache></p>
<pre><code>&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt;     

    &lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;     

    &lt;!--     
    Mandatory Default Cache configuration. These settings will be applied to caches     
    created programmtically using CacheManager.add(String cacheName)     
    --&gt;     
    &lt;!--     
       name:缓存名称。     
       maxElementsInMemory：缓存最大个数。     
       eternal:对象是否永久有效，一但设置了，timeout将不起作用。     
       timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。     
       timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。     
       overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。     
       diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。     
       maxElementsOnDisk：硬盘最大缓存个数。     
       diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.     
       diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。     
       memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。     
       clearOnFlush：内存数量最大时是否清除。     
    --&gt;     
    &lt;defaultCache     
            maxElementsInMemory=&quot;10000&quot;    
            eternal=&quot;false&quot;    
            timeToIdleSeconds=&quot;120&quot;    
            timeToLiveSeconds=&quot;120&quot;    
            overflowToDisk=&quot;true&quot;    
            maxElementsOnDisk=&quot;10000000&quot;    
            diskPersistent=&quot;false&quot;    
            diskExpiryThreadIntervalSeconds=&quot;120&quot;    
            memoryStoreEvictionPolicy=&quot;LRU&quot;    
            /&gt;     
&lt;/ehcache&gt;  
</code></pre><h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>对于经常使用的查询语句, 如果启用了查询缓存, 当第一次执行查询语句时, Hibernate 会把查询结果存放在查询缓存中. 以后再次执行该查询语句时, 只需从缓存中获得查询结果, 从而提高查询性能<br><br>查询缓存使用于如下场合:<br><br>应用程序运行时经常使用查询语句<br><br>很少对与查询语句检索到的数据进行插入, 删除和更新操作<br><br>启用查询缓存的步骤<br><br>配置二级缓存, 因为查询缓存依赖于二级缓存<br><br>在 hibernate 配置文件中启用查询缓存<br><br>对于希望启用查询缓存的查询语句, 调用 Query 的 setCacheable() 方法<br></p>
<h4 id="时间戳缓存区域"><a href="#时间戳缓存区域" class="headerlink" title="时间戳缓存区域"></a>时间戳缓存区域</h4><p>时间戳缓存区域存放了对于查询结果相关的表进行插入, 更新或删除操作的时间戳.  Hibernate 通过时间戳缓存区域来判断被缓存的查询结果是否过期, 其运行过程如下:<br><br>T1 时刻执行查询操作, 把查询结果存放在 QueryCache 区域, 记录该区域的时间戳为 T1<br><br>T2 时刻对查询结果相关的表进行更新操作, Hibernate 把 T2 时刻存放在 UpdateTimestampCache 区域.<br><br>T3 时刻执行查询结果前, 先比较 QueryCache 区域的时间戳和 UpdateTimestampCache 区域的时间戳, 若 T2 &gt;T1, 那么就丢弃原先存放在 QueryCache 区域的查询结果, 重新到数据库中查询数据, 再把结果存放到 QueryCache 区域; 若 T2 &lt; T1, 直接从 QueryCache 中获得查询结果<br></p>
<h4 id="Query-接口的-iterate-方法"><a href="#Query-接口的-iterate-方法" class="headerlink" title="Query 接口的 iterate() 方法"></a>Query 接口的 iterate() 方法</h4><p>Query 接口的 iterator() 方法<br><br>同 list() 一样也能执行查询操作<br><br>list() 方法执行的 SQL 语句包含实体类对应的数据表的所有字段<br><br>Iterator() 方法执行的SQL 语句中仅包含实体类对应的数据表的 ID 字段<br><br>当遍历访问结果集时, 该方法先到 Session 缓存及二级缓存中查看是否存在特定 OID 的对象, 如果存在, 就直接返回该对象, 如果不存在该对象就通过相应的 SQL Select 语句到数据库中加载特定的实体对象<br><br>大多数情况下, 应考虑使用 list() 方法执行查询操作. iterator() 方法仅在满足以下条件的场合, 可以<strong>稍微</strong>提高查询性能:<br><br>要查询的数据表中包含大量字段<br><br>启用了二级缓存, 且二级缓存中可能已经包含了待查询的对象<br></p>
<h4 id="管理-Session"><a href="#管理-Session" class="headerlink" title="管理 Session"></a>管理 Session</h4><p>Hibernate  自身提供了三种管理 Session 对象的方法<br><br>Session 对象的生命周期与本地线程绑定<br><br>Session 对象的生命周期与 JTA 事务绑定<br><br>Hibernate 委托程序管理 Session 对象的生命周期<br><br>在 Hibernate 的配置文件中, hibernate.current_session_context_class 属性用于指定 Session 管理方式, 可选值包括<br><br>thread: Session 对象的生命周期与本地线程绑定<br><br>jta*: Session 对象的生命周期与 JTA 事务绑定<br><br>managed: Hibernate 委托程序来管理 Session 对象的生命周期<br></p>
<h4 id="Session-对象的生命周期与本地线程绑定"><a href="#Session-对象的生命周期与本地线程绑定" class="headerlink" title="Session 对象的生命周期与本地线程绑定"></a>Session 对象的生命周期与本地线程绑定</h4><p>如果把 Hibernate 配置文件的 hibernate.current_session_context_class 属性值设为 thread, Hibernate 就会按照与本地线程绑定的方式来管理 Session<br><br>Hibernate 按以下规则把 Session 与本地线程绑定<br><br>当一个线程(threadA)第一次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法会创建一个新的 Session(sessionA) 对象, 把该对象与 threadA 绑定, 并将 sessionA 返回<br>当 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法将返回 sessionA 对象<br><br>当 threadA 提交 sessionA 对象关联的事务时, Hibernate 会自动flush sessionA 对象的缓存, 然后提交事务, 关闭 sessionA 对象. 当 threadA 撤销 sessionA 对象关联的事务时, 也会自动关闭 sessionA 对象<br><br>若 threadA 再次调用 SessionFactory 对象的 getCurrentSession() 方法时, 该方法会又创建一个新的 Session(sessionB) 对象, 把该对象与 threadA 绑定, 并将 sessionB 返回 <br></p>
<h4 id="批量处理数据"><a href="#批量处理数据" class="headerlink" title="批量处理数据"></a>批量处理数据</h4><p>批量处理数据是指在一个事务中处理大量数据.<br><br>在应用层进行批量操作, 主要有以下方式:<br><br>通过 Session <br><br>通过 HQL <br><br>通过 StatelessSession <br><br>通过 JDBC API<br></p>
<p><strong>通过 Session 来进行批量操作</strong><br><br>Session 的 save() 及 update() 方法都会把处理的对象存放在自己的缓存中. 如果通过一个 Session 对象来处理大量持久化对象, 应该及时从缓存中清空已经处理完毕并且不会再访问的对象. 具体的做法是在处理完一个对象或小批量对象后, 立即调用 flush() 方法刷新缓存, 然后在调用 clear() 方法清空缓存<br><br>通过 Session 来进行处理操作会受到以下约束<br><br>需要在  Hibernate 配置文件中设置 JDBC 单次批量处理的数目, 应保证每次向数据库发送的批量的 SQL 语句数目与 batch_size 属性一致<br><br>若对象采用 “identity” 标识符生成器, 则 Hibernate 无法在 JDBC 层进行批量插入操作<br>进行批量操作时, 建议关闭 Hibernate 的二级缓存<br><br>批量插入数据:<br></p>
<p><img src="https://i.imgur.com/3jutCzp.png" alt=""></p>
<p>批量更新: 在进行批量更新时, 如果一下子把所有对象都加载到 Session 缓存, 然后再缓存中一一更新, 显然是不可取的<br><br>使用可滚动的结果集 org.hibernate.ScrollableResults, 该对象中实际上并不包含任何对象, 只包含用于在线定位记录的游标. 只有当程序遍历访问 ScrollableResults 对象的特定元素时, 它才会到数据库中加载相应的对象. <br><br>org.hibernate.ScrollableResults 对象由 Query 的 scroll 方法返回<br><br><strong>通过 HQL 来进行批量操作</strong><br><br>注意: HQL 只支持 INSERT INTO … SELECT 形式的插入语句, 但不支持 INSERT INTO … VALUES 形式的插入语句. 所以使用 HQL 不能进行批量插入操作. <br></p>
<p><strong>通过StatelessSession来进行批量操作</strong><br>从形式上看，StatelessSession与session的用法类似。StatelessSession与session相比，有以下区别:<br><br>StatelessSession没有缓存，通过StatelessSession来加载、保存或更新后的对象处于游离状态。<br><br>StatelessSession不会与Hibernate的第二级缓存交互。<br><br>当调用StatelessSession的save()、update()或delete()方法时，这些方法会立即执行相应的SQL语句，而不会仅计划执行一条SQL语句<br><br>StatelessSession不会进行脏检查，因此修改了Customer对象属性后，还需要调用StatelessSession的update()方法来更新数据库中数据。<br><br>StatelessSession不会对关联的对象进行任何级联操作。<br><br>通过同一个StatelessSession对象两次加载OID为1的Customer对象，得到的两个对象内存地址不同。<br>StatelessSession所做的操作可以被Interceptor拦截器捕获到，但是会被Hibernate的事件处理系统忽略掉。<br></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>由于个人和时间原因，很多例子没有贴上来，时间有点赶，得睡觉了，导致这个文章看着很空洞，全是套话空话，有空会将例子补全，其实也可以去参考最新<a href="https://docs.jboss.org/hibernate/stable/orm/userguide/html_single/Hibernate_User_Guide.html" target="_blank" rel="external">官方文档</a>。</p>

        </div>
        <div class="post-reply">
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Theme by <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © Codegitz 2018
        <br>
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>