<!DOCTYPE html>
<html class="full-height">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>数据结构题目 | Codegitz&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="/**【题目】试写一算法，如果三个整数a，b和c的值不是依次非递增的，则通过交换，令其为非递增。*/void Descend(int &amp;amp;a, int &amp;amp;b, int &amp;amp;c)/ 通过交换，令 a &amp;gt;= b &amp;gt;= c /{   int d;   if(a">
<meta name="keywords" content="数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构题目">
<meta property="og:url" content="http://yoursite.com/2017/11/22/数据结构题目/index.html">
<meta property="og:site_name" content="Codegitz&#39;s Blog">
<meta property="og:description" content="/**【题目】试写一算法，如果三个整数a，b和c的值不是依次非递增的，则通过交换，令其为非递增。*/void Descend(int &amp;amp;a, int &amp;amp;b, int &amp;amp;c)/ 通过交换，令 a &amp;gt;= b &amp;gt;= c /{   int d;   if(a">
<meta property="og:updated_time" content="2017-11-22T08:13:45.950Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构题目">
<meta name="twitter:description" content="/**【题目】试写一算法，如果三个整数a，b和c的值不是依次非递增的，则通过交换，令其为非递增。*/void Descend(int &amp;amp;a, int &amp;amp;b, int &amp;amp;c)/ 通过交换，令 a &amp;gt;= b &amp;gt;= c /{   int d;   if(a">
  
    <link rel="alternate" href="/atom.xml" title="Codegitz&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="https://raw.githubusercontent.com/codegitz/TestCapacity/7acf45f27b3185ef97e94f69889d4c0253b12723/a5ea21%5B1%5D.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>
  <header id="navbar" class="overflow-hidden">
  <div class="container">
    <nav class="nav">
         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Codegitz</span>'s Blog
            </a>
         </div>
        <div class="nav-center is-hidden position-relative" id="search_container">
            <div class="nav-item full-width full-height">
                <i class="fa fa-search has-padding" aria-hidden="true"></i>
                <input type="text" id="search_input" class="search-input full-height full-width" placeholder="Search post" autofocus>
                <i id="close_search" class="fa fa-times" aria-hidden="true"></i>
            </div>
            <div id="search_result"></div>
        </div>
        <div class="nav-right nav-menu">
            <a class="nav-item" id="search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/home">
                Home
            </a>
            
            <a class="nav-item" href="/works">
                My Works
            </a>
            
            <a class="nav-item" href="/about">
                About
            </a>
            
        </div>
        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>
        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/home">
                Home
            </a>
            
            <a class="nav-item flex-1" href="/works">
                My Works
            </a>
            
            <a class="nav-item flex-1" href="/about">
                About
            </a>
            
        </div>
    </nav>
  </div>
</header>

  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 370px;
        filter: blur(10px);
        background-size: cover;
        background-color: lightsteelblue;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,.8);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>
<header>
    <div id="header_box" class="header-box"></div>
</header>
<section>
    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 70px; overflow: auto;">
            <h1 class="has-text-centered" style="padding-bottom: 10px; border-bottom: 3px solid #fff">
                <strong>数据结构题目</strong>
            </h1>
            
            <div class="is-flex align-center">
                <img class="post-avatar" src="https://raw.githubusercontent.com/codegitz/MarkdownPhotos/master/Img8049893_f.jpg">
                <span style="padding:0 10px;"> <span class="sub-title">By</span> Codegitz</span>
                <span class="post-date sub-title">at: 2017-11-22</span>
            </div>
            
                <div>
                    
                         <a class="tag is-post-tag" href="/tags/数据结构/">数据结构</a>
                    
                </div>
            
        </div>
        <div class="content" style="overflow: auto">
            <script src="/assets/js/APlayer.min.js"> </script><html><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，如果三个整数a，b和c的值<br>不是依次非递增的，则通过交换，令其为非递增。<br><strong><strong><em>*</em></strong></strong>/<br>void Descend(int &amp;a, int &amp;b, int &amp;c)<br>/<em> 通过交换，令 a &gt;= b &gt;= c </em>/<br>{   int d;<br>   if(a<b) {="" d="a;" a="b;b=d;" }="" if(a<c)="" if(b<c)="" b="c;c=d;" **********="" 【题目】试编写算法求一元多项式="" p(x)="a0" +="" a1x="" a2x^2="" ...="" anx^n="" 的值p(x0)，并确定算法中每一语句的执行次数和整个算法="" 的时间复杂度。="" float="" polynomial(int="" n,="" int="" a[],="" x)="" *="" 求一元多项式的值p(x)。="" 数组a的元素a[i]为i次项的系数，i="0,...,n" j="1,i=0;" c="1;" t="0;" while(i<="n){" while(j<="i){" j++;="" (a[i]*c);="" i++;="" return="" t;="" 【题目】已知k阶裴波那契序列的定义为="" f(0)="0," f(1)="0," ...,="" f(k-2)="0," f(k-1)="1;" f(n)="f(n-1)+f(n-2)+...+f(n-k)," n="k,k+1,..." 试编写求k阶裴波那契序列的第m项值的函数算法，="" k和m均以值调用的形式在函数参数表中出现。="" status="" fibonacci(int="" k,="" m,="" &f)="" 求k阶斐波那契序列的第m项的值f="" t[60],sum,i,j;="" if(k<2||m<0)="" error;="" if(m<k-1)="" f="0;" else="" if(m="=k-1)" for(i="0;i<=k-2;i++)" {t[i]="0;" t[k-1]="1;" {sum="0;" for(j="i-k;j<i;j++)" sum+="t[j];" t[i]="sum;}}" ok;="" 【题目】试编写算法，计算i!×2^i的值并存入数组="" a[0..n-1]的第i-1个分量中(i="1,2,…,n)。假设计" 算机中允许的整数最大值为maxint，则当对某个k="" (1≤k≤n)使k!×2^k="">MAXINT时，应按出错处理。注意<br>选择你认为较好的出错处理方法。<br><strong><strong>**</strong></strong>/<br>Status Series(int a[], int n)<br>/<em> 求i!</em>2^i序列的值并依次存入长度为n的数组a；     <em>/<br>/</em> 若所有值均不超过MAXINT，则返回OK，否则OVERFLOW <em>/<br>{<br>     int i,sum=0,sum1=1,sum2=1;<br>     int j;<br>     for(i=1;i&lt;=n;i++)<br>     {<br>        for(j=i;j&gt;0;j–) sum1</em>=j;<br>        for( j=i;j&gt;0;j–) sum2=sum2<em>2;<br><br>        sum=sum1</em>sum2;<br>        if(sum&gt;MAXINT||sum1&gt;MAXINT||sum2&gt;MAXINT)<br>         {<br><br>           return OVERFLOW;<br>           break;<br>         }<br>         a[i-1]=sum;<br>         sum1=1;sum2=1;<br>     }<br>     return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设有A、B、C、D、E五个高等院校进行田径对抗赛，<br>各院校的单项成绩均以存入计算机并构成一张表，表中每一行<br>的形式为：<br>        项目名称   性别   校名   成绩   得分<br>编写算法，处理上述表格，以统计各院校的男、女总分和团体<br>总分，并输出。<br><strong><strong>**</strong></strong>/<br>void Scores(ResultType <em>result, ScoreType </em>score)<br>/<em> 求各校的男、女总分和团体总分,并依次存入数组score </em>/<br>/<em> 假设比赛结果已经储存在result[ ]数组中,            </em>/<br>/<em> 并以特殊记录 {“”, male, ‘ ‘, “”, 0 }（域scorce=0）</em>/<br>/<em> 表示结束                                          </em>/<br>{<br>    typedef enum {female,male} Sex;<br>typedef struct{<br>  char <em>sport;     // 项目名称<br>  Sex  gender;     // 性别（女：female；男：male）<br>  char schoolname; // 校名为’A’,’B’,’C’,’D’或’E’<br>  char </em>result;    // 成绩<br>  int score;       // 得分（7,5,4,3,2或1）<br>} ResultType;<br><br>typedef struct{<br>  int malescore;   // 男子总分<br>  int femalescore; // 女子总分<br>  int totalscore;  // 男女团体总分<br>} ScoreType;<br><br>   int i=0;<br> while(result[i].sport!=NULL)<br> {<br> switch(result[i].schoolname)     /<em>使用switch语句记录各院校的成绩</em>/<br> {<br> case ‘A’:<br> score[0].totalscore+=result[i].score;<br><br> if(result[i].gender==male)<br> score[0].malescore+=result[i].score;<br> else<br> score[0].femalescore+=result[i].score;<br> break;<br> case ‘B’:<br> score[1].totalscore+=result[i].score;<br> if(result[i].gender==male)<br> score[1].malescore+=result[i].score;<br> else<br> score[1].femalescore+=result[i].score;<br> break;<br> case ‘C’:<br> score[2].totalscore+=result[i].score;<br> if(result[i].gender==male)<br> score[2].malescore+=result[i].score;<br> else<br> score[2].femalescore+=result[i].score;<br> break;<br> case ‘D’:<br> score[3].totalscore+=result[i].score;<br> if(result[i].gender==male)<br> score[3].malescore+=result[i].score;<br> else<br> score[3].femalescore+=result[i].score;<br> break;<br> case ‘E’:<br> score[4].totalscore+=result[i].score;<br> if(result[i].gender==male)<br> score[4].malescore+=result[i].score;<br> else<br> score[4].femalescore+=result[i].score;<br> break;<br> }<br> i++;<br> }<br> int j;<br> for( j=0;j<5;j++) {="" printf("the="" school="" %s:="" ",="" result[i].schoolname)="" ;="" *输出各院校的男女总分和团体总分*="" printf("total:="" %f",&score[i].totalscore);="" printf("male:="" %f",&score[i].malescore);="" printf("female:="" %f",&score[i].femalescore);="" }="" **********="" 【题目】试写一算法，对序列s的第i个元素赋以值e。="" 序列的类型定义为：="" typedef="" struct="" elemtype="" *elem;="" int="" length;="" sequence;="" ***********="" status="" assign(sequence="" &s,="" i,="" e)="" *="" 对序列s的第i个元素赋以值e，并返回ok。*="" 若s或i不合法，则赋值失败，返回error="" if(i<0||i="">S.length||S.elem==NULL) return ERROR;<br>    else<br>    {<br>      S.elem[i]=e;<br>    }<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，由长度为n的一维数组a构建一个序列S。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br>Status CreateSequence(Sequence &amp;S, int n, ElemType <em>a)<br>/</em> 由长度为n的一维数组a构建一个序列S，并返回OK。<em>/<br>/</em> 若构建失败，则返回ERROR                       <em>/<br>{<br>   S.elem=(ElemType</em>)malloc(n<em>sizeof(ElemType));<br>   if(S.elem==a||n&lt;=0) return ERROR;<br>   S.elem = a;<br>   S.length = n;<br>  if(&amp;S.elem[0]==NULL) return ERROR;<br>    else return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode </em>next;<br>    } LNode, <em>LinkList;<br>试写一函数，构建一个值为x的结点。<br><strong><strong>**</strong></strong></em>/<br>LinkList MakeNode(ElemType x)<br>/<em> 构建一个值为x的结点，并返回其指针。</em>/<br>/<em> 若构建失败，则返回NULL。           </em>/<br>{   LNode <em>p;<br>    p = (LNode</em>)malloc(sizeof(LNode));<br>    if(p)<br>    {<br>      p-&gt;data=x;<br>      p-&gt;next=NULL;<br>    }<br>    else return NULL;<br>    return p;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2且两个结点的值依次为x和y的链表。<br><strong><strong>**</strong></strong>/<br>LinkList CreateLinkList(ElemType x, ElemType y)<br>/<em> 构建其两个结点的值依次为x和y的链表。</em>/<br>/<em> 若构建失败，则返回NULL。            </em>/<br>{<br>    LNode <em>p1,</em>p2;<br>    p1 = (LNode<em>)malloc(sizeof(LNode));<br>    p2 = (LNode</em>)malloc(sizeof(LNode));<br>    if(p1)<br>    {<br>      p1-&gt;data=x;<br>      p1-&gt;next=p2;<br>    }else return NULL;<br>    if(p2)<br>    {<br>      p2-&gt;data=y;<br>      p2-&gt;next=NULL;<br>    }<br><br>    else return NULL;<br>    return p1;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2的升序链表，两个结点的值<br>分别为x和y，但应小的在前，大的在后。<br><strong><strong>**</strong></strong>/<br>LinkList CreateOrdLList(ElemType x, ElemType y)<br>/<em> 构建长度为2的升序链表。  </em>/<br>/<em> 若构建失败，则返回NULL。</em>/<br>{<br>       LNode <em>p, </em>q;<br>     p = (LNode<em>)malloc(sizeof(LNode));<br>     q = (LNode</em>)malloc(sizeof(LNode));<br>     p-&gt;data = x;<br>     q-&gt;data = y;<br>     if(x&gt;y){<br>     q-&gt;next = p;<br>     p-&gt;next = NULL;<br>     return q;<br>     }else{<br>     p-&gt;next = q;<br>     q-&gt;next = NULL;<br>     return p;<br>     }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的判空操作<br>StackEmpty_Sq(SqStack S)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br><strong><strong>**</strong></strong></em>/<br>Status StackEmpty_Sq(SqStack S)<br>/<em> 对顺序栈S判空。                      </em>/<br>/<em> 若S是空栈，则返回TRUE；否则返回FALSE </em>/<br>{<br>    if(S.elem==NULL||S.top==NULL) return TRUE;<br>    else return FALSE;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的取栈顶元素操作<br>GetTop_Sq(SqStack S, ElemType &amp;e)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem;  // 存储空间的基址<br>  int top;         // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;        // 当前分配的存储容量<br>  int increment;   // 扩容时，增加的存储容量<br>} SqStack;         // 顺序栈<br><strong><strong>**</strong></strong></em>/<br>Status GetTop_Sq(SqStack S, ElemType &amp;e)<br>/<em> 取顺序栈S的栈顶元素到e，并返回OK；</em>/<br>/<em> 若失败，则返回ERROR。              </em>/<br>{<br>   if(S.top==0){<br>      return ERROR;<br>}<br>    e=S.elem[S.top-1];<br>    return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的出栈操作<br>Pop_Sq(SqStack &amp;S, ElemType &amp;e)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem;  // 存储空间的基址<br>  int top;         // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;        // 当前分配的存储容量<br>  int increment;   // 扩容时，增加的存储容量<br>} SqStack;         // 顺序栈<br><strong><strong>**</strong></strong></em>/<br>Status Pop_Sq(SqStack &amp;S, ElemType &amp;e)<br>/<em> 顺序栈S的栈顶元素出栈到e，并返回OK；</em>/<br>/<em> 若失败，则返回ERROR。               </em>/<br>{<br>     if(0==S.top) return ERROR;<br>    e=S.elem[–S.top];<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>构建初始容量和扩容增量分别为size和inc的空顺序栈S。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br>Status InitStack_Sq2(SqStack2 &amp;S, int size, int inc)<br>/<em> 构建初始容量和扩容增量分别为size和inc的空顺序栈S。</em>/<br>/<em> 若成功，则返回OK；否则返回ERROR。                 </em>/<br>{<br>    S.elem=(ElemType<em>)malloc(size</em>sizeof(ElemType));<br>    if(NULL==S.elem) return OVERFLOW;<br>    if(size&lt;=0||inc&lt;=0) return ERROR;<br>    S.top=S.elem;<br>    S.size=size;<br>    S.increment=inc;<br>    return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的判空操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br>Status StackEmpty_Sq2(SqStack2 S)<br>/<em> 对顺序栈S判空。                      </em>/<br>/<em> 若S是空栈，则返回TRUE；否则返回FALSE </em>/<br>{<br>     if(S.top==S.elem)return TRUE;<br>    else  return FALSE;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的入栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br>Status Push_Sq2(SqStack2 &amp;S, ElemType e)<br>/<em> 若顺序栈S是满的，则扩容，若失败则返回ERROR。</em>/<br>/<em> 将e压入S，返回OK。                          </em>/<br>{<br>    ElemType <em>newbase;<br>    if((S.top-S.elem)&gt;S.size){<br>       newbase=(ElemType</em>)realloc(S.elem,(S.size+S.increment)<em>sizeof(ElemType));<br>       if(NULL==newbase) return ERROR;<br>       S.elem=newbase;<br>       S.size=S.size+S.increment;<br>    }
     </em>S.top=e;<br>    S.top++;<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的出栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br>Status Pop_Sq2(SqStack2 &amp;S, ElemType &amp;e)<br>/<em> 若顺序栈S是空的，则返回ERROR；    </em>/<br>/<em> 否则将S的栈顶元素出栈到e，返回OK。</em>/<br>{<br>     if(S.top==S.elem) return ERROR;<br>    e=<em>(–S.top);<br>    return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType </em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br>可调用顺序栈接口中下列函数：<br>Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈S<br>Status DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈S<br>Status StackEmpty_Sq(SqStack S);    // 栈S判空，若空则返回TRUE，否则FALSE<br>Status Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈S<br>Status Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e<br><strong><strong><em>*</em></strong></strong>/<br>Status CopyStack_Sq(SqStack S1, SqStack &amp;S2)<br>/<em> 借助辅助栈，复制顺序栈S1得到S2。    </em>/<br>/<em> 若复制成功，则返回TRUE；否则FALSE。</em>/<br>{<br>    SqStack S3;<br>    ElemType e;<br>    InitStack_Sq(S3,S1.size,S1.increment);<br>    InitStack_Sq(S2,S1.size,S1.increment);<br>    while(StackEmpty_Sq(S1)!=TRUE){<br>       Pop_Sq(S1,e);<br>       Push_Sq(S3,e);<br>       }<br>    while(StackEmpty_Sq(S3)!=TRUE){<br>       Pop_Sq(S3,e);<br>       Push_Sq(S2,e);<br>     }<br><br>     return TRUE;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，求循环队列的长度。<br>循环队列的类型定义为：<br>typedef struct {<br>  ElemType <em>base;  // 存储空间的基址<br>  int front;       // 队头位标<br>  int rear;        // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;     // 最大长度<br>} SqQueue;<br><strong><strong>**</strong></strong></em>/<br>int QueueLength_Sq(SqQueue Q)<br>/<em> 返回队列Q中元素个数，即队列的长度。</em>/<br>{    return  (Q.rear-Q.front+Q.maxSize)%Q.maxSize;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】如果希望循环队列中的元素都能得到利用，<br>则可设置一个标志域tag，并以tag值为0或1来区分尾<br>指针和头指针值相同时的队列状态是”空”还是”满”。<br>试编写与此结构相应的入队列和出队列的算法。<br>本题的循环队列CTagQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int tag;<br>  int front;<br>  int rear;<br>} CTagQueue;<br><strong><strong>**</strong></strong>/<br>Status EnCQueue(CTagQueue &amp;Q, ElemType x)<br>/<em> 将元素x加入队列Q，并返回OK；</em>/<br>/<em> 若失败，则返回ERROR。       </em>/<br>{<br>     if(Q.tag==1&amp;&amp;Q.front==Q.rear)return ERROR;<br>   Q.elem[Q.rear]=x;<br>   Q.rear=(Q.rear+1)%MAXSIZE;<br>   if(Q.front==Q.rear)<br>   Q.tag=1;<br>   return OK;<br>}<br><br>Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)<br>/<em> 将队列Q的队头元素退队到x，并返回OK；</em>/<br>/<em> 若失败，则返回ERROR。               </em>/<br>{ if(Q.tag==0&amp;&amp;Q.front==Q.rear)<br>       return ERROR;<br>      x=Q.elem[Q.front];<br>      Q.front=(Q.front+1)%MAXSIZE;<br>      if(Q.front==Q.rear)<br>         Q.tag=0;<br>      return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设将循环队列定义为：以域变量rear<br>和length分别指示循环队列中队尾元素的位置和内<br>含元素的个数。试给出此循环队列的队满条件，并<br>写出相应的入队列和出队列的算法（在出队列的算<br>法中要返回队头元素）。<br>本题的循环队列CLenQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int length;<br>  int rear;<br>} CLenQueue;<br><strong><strong>**</strong></strong>/<br>Status EnCQueue(CLenQueue &amp;Q, ElemType x)<br>  /<em> 将元素x加入队列Q，并返回OK；</em>/<br>  /<em> 若失败，则返回ERROR。       </em>/<br>{    if(Q.length==MAXQSIZE) return ERROR;<br>    Q.length++;<br>    Q.rear=(Q.rear+1)%MAXQSIZE;<br>    Q.elem[Q.rear]=x;<br>    return TRUE;<br><br>}<br>Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x)<br>  /<em> 将队列Q的队头元素退队到x，并返回OK；</em>/<br>  /<em> 若失败，则返回ERROR。               </em>/<br>{<br>    int front;<br>    if(Q.length==0) return ERROR;<br>      Q.length–;<br>    front=MAXQSIZE-Q.length+Q.rear;<br>    x=Q.elem[front%MAXQSIZE];<br>    front=(front+1)%MAXQSIZE;<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】已知k阶斐波那契序列的定义为:<br>    f0=0,  f1=0,  …,  fk-2=0,  fk-1=1;<br>    fn=fn-1+fn-2+…+fn-k,  n=k,k+1,…<br>试利用循环队列编写求k阶斐波那契序列中第<br>n+1项fn的算法。<br><br>本题的循环队列的类型定义如下：<br>typedef struct {<br>  ElemType <em>base; // 存储空间的基址<br>  int front;      // 队头位标<br>  int rear;       // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;    // 最大长度<br>} SqQueue;<br><strong><strong>**</strong></strong>/<br>long Fib(int k, int n)<br>/</em> 求k阶斐波那契序列的第n+1项fn <em>/<br>{<br>    int i,j ;<br>   if(1 &gt;=k|| 0 &gt; n) return ERROR;<br>   SqQueue fib;<br>   fib.base = (ElemType</em>)malloc(30<em>sizeof(ElemType));<br>   fib.maxSize = 30;<br>   fib.front = fib.rear = 0;<br>   for(;fib.rear &lt; k;fib.rear++)<br>        {<br>        if(fib.rear<k-1) fib.base[fib.rear]="0;" else="" }="" while(fib.rear="" <="n)" {="" j="1;" while(j="" +="fib.base[fib.rear-j];" j++;="" fib.rear++;="" return="" fib.base[n];="" **********="" 【题目】设a="(a1,…,am)和B=(b1,…,bn)均为有序顺序表，" a'和b'分别为a和b中除去最大共同前缀后的子表（例如，="" a="(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大" 的共同前缀为(x,y,y,z)，="" 在两表中除去最大共同前缀后="" 的子表分别为a'="(x,z)和B'=(y,x,x,z)）。若A'=B'=空表，" 则a="B；若A'=空表，而B'≠" 空表，或者两者均不为空表，="" 且a'的首元小于b'的首元，则a<b；否则a="">B。试写一个比<br>较A和B大小的算法。（注意：在算法中，不要破坏原表A<br>和B，也不一定先求得A’和B’才进行比较）。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType </k-1)></em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>**</strong></strong>/<br>char Compare(SqList A, SqList B)<br>/<em> 比较顺序表A和B,      </em>/<br>/<em>   返回’&lt;’,若A&lt;B;    </em>/<br>/<em>       ‘=’, 若A=B;    </em>/<br>/<em>       ‘&gt;’, 若A&gt;B     </em>/<br>{<br>     int i;<br> if(0 == A.length &amp;&amp; 0 == B.length)<br>        return ‘=’;<br> else<br> {<br>  for(i = 0; i &lt; A.length||i&lt; B.length;i++)<br>      {<br>         if(A.elem[i] &lt; B.elem[i])<br>                 return ‘&lt;’;<br>         if(A.elem[i] &gt; B.elem[i])<br>                  return ‘&gt;’;<br>         }<br>  if(A.length &gt; B.length) return ‘&gt;’;<br>  if(A.length &lt; B.length) return ‘&lt;’;<br>  return ‘=’;<br><br> }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序表的就地逆置，<br>即利用原表的存储空间将线性表(a1,a2,…,an)<br>逆置为(an,an-1,…,a1)。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>**</strong></strong>/<br>void Inverse(SqList &amp;L)<br>{  int i;<br>   ElemType temp;<br>   for(i=0;i&lt;L.length/2;i++) {<br>   temp=L.elem[i];<br>   L.elem[i]=L.elem[L.length-1-i];<br>   L.elem[L.length-1-i]=temp; }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式<br>项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0<br>为给定值）。<br><br>一元稀疏多项式的顺序存储结构:<br>typedef struct {<br>  int  coef;  // 系数<br>  int   exp;  // 指数<br>} Term;<br><br>typedef struct {<br>  Term  </em>elem;   // 存储空间基址<br>  int    length; // 长度（项数）<br>} Poly;<br><strong><strong>**</strong></strong>/<br>float Evaluate(Poly P, float x)<br>/<em> P.elem[i].coef 存放ai，                        </em>/<br>/<em> P.elem[i].exp存放ei (i=1,2,…,m)              </em>/<br>/<em> 本算法计算并返回多项式的值。不判别溢出。       </em>/<br>/<em> 入口时要求0≤e1&lt;e2&lt;…&lt;em，算法内不对此再作验证</em>/<br>{   int i,j;<br>    float sum = 0,sum1 ;<br>    for(i = 0;i <p.length; i++)="" {="" sum1="P.elem[i].coef" ;="" for(j="0;j" <="" p.elem[i].exp;j++)="" sum="" +="sum1;" }="" return="" sum;="" **********="" 【题目】假设有两个集合a和b分别用两个线性表la和lb="" 表示(即：线性表中的数据元素即为集合中的成员），="" 试写一算法，求并集a＝a∪b。="" 顺序表类型定义如下="" typedef="" struct="" elemtype="" *elem;="" 存储空间的基址="" int="" length;="" 当前长度="" size;="" 存储容量="" increment;="" 空间不够增加空间大小="" sqlist;="" 顺序表="" 可调用顺序表的以下接口函数：="" status="" initlist_sq(sqlist="" &l,="" size,="" inc);="" 初始化顺序表l="" listlength_sq(sqlist="" l);="" 返回顺序表l中元素个数="" getelem_sq(sqlist="" l,="" i,="" &e);="" 用e返回顺序表l中第i个元素的值="" search_sq(sqlist="" e);="" 在顺序表l顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1="" append_sq(sqlist="" 在顺序表l表尾添加元素e="" void="" union(sqlist="" &la,="" sqlist="" lb)="" i,j;="" a;="" for(i="0;i" lb.length;i++)="" getelem_sq(lb,="" i+1,="" a);="" if(="" -1="=" search_sq(la,="" a))="" append_sq(la,="" la.length="ListLength_Sq(La);" 【题目】试写一算法，实现链栈的判空操作。="" 链栈的类型定义为：="" lsnode="" data;="" 数据域="" *next;="" 指针域="" lsnode,="" *lstack;="" 结点和链栈类型="" ***********="" stackempty_l(lstack="" s)="" *="" 对链栈s判空。若s是空栈，则返回true；否则返回false="" if(null="=S)" true;="" else="" false;="" 【题目】试写一算法，实现链栈的取栈顶元素操作。="" gettop_l(lstack="" s,="" &e)="" 取链栈s的栈顶元素到e，并返回ok;="" 若s是空栈，则失败，返回error。="" error;="" e="S-">data;<br>     return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的判空操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/<br>Status QueueEmpty_LQ(LQueue Q)<br>/<em> 判定链队列Q是否为空队列。           </em>/<br>/<em> 若Q是空队列，则返回TRUE，否则FALSE。</em>/<br>{   if(NULL == Q.front) return TRUE;<br>    else return FALSE;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的求队列长度操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/<br>int QueueLength_LQ(LQueue Q)<br>/<em> 求链队列Q的长度并返回其值</em>/<br>{<br>   LQNode <em>p = Q.front;<br>   int i=1;<br>   if(Q.front == NULL) return ERROR;<br>   while(p!= Q.rear) {<br>    p = p-&gt;next;<br>    i++;<br>   }<br>   return i;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设以带头结点的循环链表表示队列，并且<br>只设一个指针指向队尾元素结点(注意不设头指针)，<br>试编写相应的队列初始化、入队列和出队列的算法。<br>带头结点循环链队列CLQueue的类型定义为：<br>typedef struct LQNode {<br>  ElemType data;<br>  struct LQNode </em>next;<br>} LQNode, <em>CLQueue;<br><strong><strong>**</strong></strong>/<br>Status InitCLQueue(CLQueue &amp;rear) // 初始化空队列<br>{   LQNode </em>p;<br>  if(NULL ==(p = (LQNode<em>)malloc(sizeof(LQNode))))<br>   return ERROR;<br>   p-&gt;next = p;<br>   rear = p;<br>   return OK;<br>}<br><br>Status EnCLQueue(CLQueue &amp;rear, ElemType x) // 入队<br>{  LQNode </em>p;<br>    if(NULL ==(p = (LQNode<em>)malloc(sizeof(LQNode))))<br>   return ERROR;<br>     p-&gt;data = x;<br>     p-&gt;next=rear-&gt;next;<br>     rear-&gt;next = p;<br>     rear = p;<br>      return OK;<br>}<br><br>Status DeCLQueue(CLQueue &amp;rear, ElemType &amp;x) // 出队<br>{<br>      if(rear == rear-&gt;next )<br>        return ERROR;<br>  else<br>  {<br>   x = rear-&gt;next-&gt;next-&gt;data;<br>   rear-&gt;next-&gt;next = rear-&gt;next-&gt;next-&gt;next;<br>  }<br>  return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的判空操作。<br><br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  </em>next;<br>} LNode, <em>LinkList; // 结点和结点指针类型<br><strong><strong>**</strong></strong></em>/<br>Status ListEmpty_L(LinkList L)<br>/<em> 判定带头结点单链表L是否为空链表。   </em>/<br>/<em> 若L是空链表，则返回TRUE，否则FALSE。</em>/<br>{<br>   if(NULL == L-&gt;next) return TRUE;<br>   else return  FALSE;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的销毁操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/<br>Status DestroyList_L(LinkList &amp;L)<br>/<em> 销毁带头结点单链表L，并返回OK。</em>/<br>{<br>    //if(NULL == L||NULL == L-&gt;next) return ERROR；<br>    free(L);<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的清空操作。<br><br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/<br>Status ClearList_L(LinkList &amp;L)<br>/<em> 将带头结点单链表L置为空表，并返回OK。</em>/<br>/<em> 若L不是带头结点单链表，则返回ERROR。</em>/<br>{  if(L == NULL) return ERROR;<br>    if(L-&gt;next == NULL) return OK;<br>    L-&gt;next  = NULL;<br>    return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的求表长度操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/<br>int ListLength_L(LinkList L)<br>/<em> 求带头结点单链表L的长度，并返回长度值。</em>/<br>/<em> 若L不是带头结点单链表，则返回-1。      </em>/<br>{  LNode <em>p;<br>    int i = 0;<br>   if(NULL == L) return -1;<br>   p = L-&gt;next;<br>   while(p != NULL)<br>   {<br>     p = p-&gt;next;<br>     i++;<br>   }<br>   return i;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表L插入第i元素e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode </em>next;<br>} LNode, <em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Insert_L(LinkList L, int i, ElemType e)<br>/</em> 在带头结点单链表L插入第i元素e，并返回OK。<em>/<br>/</em> 若参数不合理，则返回ERROR。              <em>/<br>{<br>    if(i == 0 )  return ERROR;<br>  LinkList p,q,p1,a,b;<br>  int j = 0 ,k=0;<br>  q = (LNode</em>)malloc(sizeof(LNode)) ;<br>  q-&gt;data = e;<br>  q-&gt;next = NULL;<br>  p1 = L;<br>  b=L;<br>  while(b !=NULL)<br>  {<br>    a =  b;<br>    b = a-&gt;next;<br>    k++;<br>  }<br>  if(k &lt; i )  return ERROR;<br>  while(j <i) {="" p="p1;" p1="p-">next;<br>      j++;<br><br><br>  }<br> q-&gt;next = p-&gt;next;<br>  p-&gt;next =  q;<br>  return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素到e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Delete_L(LinkList L, int i, ElemType &amp;e)<br>/<em> 在带头结点单链表L删除第i元素到e，并返回OK。</em>/<br>/<em> 若参数不合理，则返回ERROR。                </em>/<br>{<br>    LinkList p,q1,q2,q3;<br>    int j=0;<br>    p=L;<br>    while(p-&gt;next){<br>     q1 = p;<br>     p=q1-&gt;next;<br>     if(j==i-1)<br>     {<br>       q2 = q1;<br>       q3 = p;<br>     }<br>      ++j;<br>    }<br>   if(i== 0||j<i) return="" error;="" e="q3-">data;<br>    q2-&gt;next = q3-&gt;next;<br>    return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表的第i元素起的<br>所有元素从链表移除，并构成一个带头结点的新链表。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Split_L(LinkList L, LinkList &amp;Li, int i)<br>/<em> 在带头结点单链表L的第i元素起的所有元素</em>/<br>/<em> 移除，并构成带头结点链表Li，返回OK。   </em>/<br>/<em> 若参数不合理，则Li为NULL，返回ERROR。  </em>/<br>{<br>      if(i&lt;=0||L==null) {<br>     Li==null;<br>     return ERROR;<br>     }<br>   LinkList a,b,c;<br>   int j=0,k=0;<br>   Li=(LNode<em>)malloc(sizeof(LNode));<br>   Li-&gt;next=null;<br>   a=L;<br>   b=L;<br>   while(a-&gt;next!=null){<br>     j++;<br>     a=a-&gt;next;<br>   }<br>   if(j<i) {="" li="null;" return="" error;="" }="" while(k<i-1){="" b="b-">next;<br>   k++;<br>   }<br>  c=b-&gt;next;<br>  Li-&gt;next=c;<br>  b-&gt;next=null;<br>  return OK;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素<br>起的所有元素。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode </i)></em>next;<br>} LNode, <em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Cut_L(LinkList L, int i)<br>/</em> 在带头结点单链表L删除第i元素起的所有元素，并返回OK。<em>/<br>/</em> 若参数不合理，则返回ERROR。                         <em>/<br>{    LinkList p1,p2,p3;<br>    int j=0,k=0;<br>    p2 =L;<br>    p1=L;<br>    p3=L;<br>    if(NULL == L||L-&gt;next ==NULL) return ERROR;<br>     while(p3-&gt;next!=null){<br>       p3=p3-&gt;next;<br>       j++;<br>     }<br>     if(j &lt; i||i==0) return ERROR;<br><br>      while(k<i){ p1="p2;" p2="p1-">next;<br>       k++;<br>     }<br>      p1-&gt;next=null;<br>      return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>为x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode </i){></em>next;<br>} LNode, <em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status DeleteX_L(LinkList L, ElemType x)<br>/</em> 删除带头结点单链表L中所有值为x的元素，      <em>/<br>/</em> 并释放被删结点空间，返回实际删除的元素个数。<em>/<br>{   LinkList p1,p2,p3;<br>    int j = 0;<br>    if(NULL ==L) return ERROR;<br>    p1=p2=L;<br>    while(p2!=NULL){<br>      p2 = p1-&gt;next;<br>      if(p2-&gt;data == x){<br>        p3 = p2;<br>        p2 = p3-&gt;next;<br>        p1-&gt;next = p2;<br>        free(p3);<br>        j++;<br>      }<br>      else if(p2-&gt;data!=x)<br>       {<br>          p1 = p2;<br>          p2 = p1-&gt;next;<br>       }<br><br><br>    }<br><br>    return j;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>小于x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode </em>next;<br>} LNode, <em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status DeleteSome_L(LinkList L, ElemType x)<br>/</em> 删除带头结点单链表L中所有值小于x的元素，    <em>/<br>/</em> 并释放被删结点空间，返回实际删除的元素个数。<em>/<br>{     LinkList p1,p2,p3;<br>    int j = 0; p1=p2=L;<br>    if(NULL == p1) return j;<br><br>    while(p2!=NULL){<br>      p2 = p1-&gt;next;<br>      if(p2-&gt;data &lt; x &amp;&amp;p2!=null){<br>        p3 = p2;<br>        p2 = p3-&gt;next;<br>        p1-&gt;next = p2;<br>        free(p3);<br>        j++;<br>      }<br>      else if(p2-&gt;data &gt;= x)<br>       {<br>          p1 = p2;<br>          p2 = p1-&gt;next;<br>       }<br><br><br>    }<br><br>    return j;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试以顺序表L的L.rcd[L.length+1]作为监视哨，<br>改写教材5.2节中给出的升序直接插入排序算法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // r[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/<br>void InsertSort(RcdSqList &amp;L)<br>{<br>   int i,j;<br>   for(i = 1; i&lt;L.length; i++){<br>     if(L.rcd[i+1].key &lt; L.rcd[i].key) {<br>       L.rcd[0] = L.rcd[i+1];<br>       j = i+1;<br>       do{<br>         j–;L.rcd[j+1] = L.rcd[j];<br>       } while(L.rcd[0].key&lt;L.rcd[j-1].key);<br>       L.rcd[j] = L.rcd[0];<br>     }<br>   }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】如下所述，改写教材1.5节的冒泡排序算法：<br>将算法中用以起控制作用的布尔变量change改为一个整型<br>变量，指示每一趟排序中进行交换的最后一个记录的位置，<br>并以它作为下一趟起泡排序循环终止的控制值。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // r[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/<br>void BubbleSort(RcdSqList &amp;L)<br>/</em> 元素比较和交换必须调用如下定义的比较函数和交换函数：<em>/<br>/</em> Status LT(RedType a, RedType b);   比较：”&lt;”        <em>/<br>/</em> Status GT(RedType a, RedType b);   比较：”&gt;”        <em>/<br>/</em> void Swap(RedType &amp;a, RedType &amp;b); 交换             <em>/<br>{  int i,change,j,k;<br>   for(i = L.length,change = 0;i&gt;1;i–)<br>      {<br>       change = i;<br>      for(j = 1;j&lt;i;++j)<br>        {<br>        if(GT(L.rcd[j],L.rcd[j+1]))<br>           {<br>            Swap(L.rcd[j],L.rcd[j+1]);<br>            k++;<br>            change = j+1;<br>            }<br><br>        }<br>       while(L.rcd[change].key == L.rcd[change-1].key)<br>            {            //用while来跳过那些相同关键字<br>             change = change - 1;<br>            }<br>      i = change;<br>       if(k == 0) i = 1; //当有一次比较没有交换时使i= 1结束操作<br><br>     k=0;<br>      }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】已知记录序列L.rcd[1..L.length]中的关键<br>字各不相同，可按如下所述实现计数排序：另设数组<br>c[1..n]，对每个记录a[i]， 统计序列中关键字比它<br>小的记录个数存于c[i]，则c[i]=0的记录必为关键字<br>最小的记录，然后依c[i]值的大小对序列中记录进行<br>重新排列。试编写算法实现上述排序方法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // r[0]闲置<br>   int     length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/<br>void CountSort(RcdSqList &amp;L)<br>/</em> 采用顺序表存储结构，在函数内自行定义计数数组c <em>/<br>{<br>   int k = L.length ;<br>  RcdSqList L1;<br>  int c[27];<br>  int i,j;<br>  for(i = 1;i &lt;= L.length ;i++)<br>     for(j = 1;j &lt;= L.length;j++)<br>        {<br>         if(L.rcd[i].key&lt;L.rcd[j].key)<br>            c[i]++;<br>        }<br><br>    for(i = 1;i&lt;=L.length ;i++)<br>        {<br>         L1.rcd[c[i]+1].key = L.rcd[i].key;<br>        }<br>    for(i = 1;i&lt;=L.length ;i++)<br>        {<br>         L.rcd[L.length-i+1].key = L1.rcd[i].key;<br>        }<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】已知某哈希表的装载因子小于1，哈希函数H(key)<br>为关键字(标识符)的第一个字母在字母表中的序号，处理<br>冲突的方法为线性探测开放定址法。试编写一个按第一个<br>字母的顺序输出哈希表中所有关键字的算法。<br>哈希表的类型HashTable定义如下：<br>#define SUCCESS    1<br>#define UNSUCCESS  0<br>#define DUPLICATE -1`<br>typedef char StrKeyType[4];<br>typedef struct {<br>   StrKeyType key; // 关键字项<br>   int    tag;     // 标记 0:空；1:有效; -1:已删除<br>   void  </em>any;     // 其他信息<br>} RcdType;<br>typedef struct {<br>  RcdType <em>rcd;    // 存储空间基址<br>  int      size;   // 哈希表容量<br>  int      count;  // 表中当前记录个数<br>} HashTable;<br><strong><strong>**</strong></strong>/<br>void PrintKeys(HashTable ht, void(</em>print)(StrKeyType))<br>/<em> 依题意用print输出关键字</em>/<br>{<br>     int n,i,size;<br>    char c;<br>    for(c=’A’;c&lt;=’Z’;c++){<br>    for(i=0;i<ht.size;i++){ 0="" 1="" 7="" if(ht.rcd[i].tag="=-1)" continue;="" if(ht.rcd[i].key[0]="=c)" print(ht.rcd[i].key);="" }="" **********="" 【题目】假设哈希表长为m，哈希函数为h(x)，用链地址法="" 处理冲突。试编写输入一组关键字并建造哈希表的算法。="" 哈希表的类型chainhashtab定义如下：="" #define="" num="" nullkey="" -1="" success="" unsuccess="" duplicate="" typedef="" char="" hkeytype;="" struct="" hnode="" {="" hkeytype="" data;="" hnode*="" next;="" }*hlink;="" hlink="" *rcd;="" 指针存储基址，动态分配数组="" int="" count;="" 当前表中含有的记录个数="" size;="" 哈希表的当前容量="" }chainhashtab;="" 链地址哈希表="" hash(chainhashtab="" h,="" k)="" 哈希函数="" return="" k="" %="" h.size;="" status="" collision(chainhashtab="" &p)="" 求得下一个探查地址p="" if="" (p="" &&="" p-="">next) {<br>    p = p-&gt;next;<br>    return SUCCESS;<br>  } else return UNSUCCESS;<br>}<br><strong><strong>**</strong></strong>/<br>int BuildHashTab(ChainHashTab &amp;H, int n, HKeyType es[])<br>/<em> 直接调用下列函数                             </em>/<br>/<em> 哈希函数：                                   </em>/<br>/<em>    int Hash(ChainHashTab H, HKeyType k);     </em>/<br>/<em> 冲突处理函数：                               </em>/<br>/<em>    int Collision(ChainHashTab H, HLink &amp;p);  </em>/<br>{<br>    int i,k,j;<br>  HLink p,q,p1;<br>  H.rcd = (HLink<em>)malloc(7</em>sizeof(HLink));<br>  H.size = 7;<br>  H.count = 0;<br>  for(i = 0;es[i] &gt;= ‘A’;i++)<br>    {<br>     p = (HNode<em>)malloc(sizeof(HNode));<br>     p-&gt;next = NULL;<br>     p-&gt;data = es[i];<br>     k = Hash( H, p-&gt;data) ;<br>     if(NULL !=H.rcd[k])<br>        {  // 判断其中是否有相同的HKeyType<br>         p1 =  H.rcd[k];<br>         while(NULL != p1)<br>         {  //用j作为标记，如果j = 0表示没有相同的，插入p<br>           if(p1-&gt;data == p-&gt;data)<br>                j = 1;<br>           p1 = p1-&gt;next;<br>         }<br>         if(j == 0)<br>            {<br>             q =  H.rcd[k];<br>             p-&gt;next = q;<br>             H.rcd[k] = p;<br><br>             }<br>           j = 0;<br>        }<br>     else<br>        H.rcd[k] = p; //为什么H.rcd[k]-&gt;next = p;不会报错<br>    H.count++;<br>    }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试编写如下定义的递归函数的递归算法:<br>    g(m,n) = 0             当m=0,n&gt;=0<br>    g(m,n) = g(m-1,2n)+n   当m&gt;0,n&gt;=0<br><strong><strong>**</strong></strong>/<br>int G(int m, int n)<br>/</em> 如果 m<0或n<0则返回-1 *="" {="" if(m<0||n<0)="" return="" -1;="" else="" if(m="=0&&n">=0)<br>     return 0;<br>     else if(m&gt;0&amp;&amp;n&gt;=0)<br>       return G(m-1,2<em>n)+n;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写出求递归函数F(n)的递归算法：<br>    F(n) = n+1      当n=0<br>    F(n) = nF(n/2)  当n&gt;0<br><strong><strong>**</strong></strong>/<br>int F(int n)<br>/</em> 如果 n<0则返回-1 *="" {="" if(n<0)="" return="" -1;="" else="" if(n="=0)" n+1;="">0) return n<em>F(n/2);<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p</em>p-A|<e sqrt(a,p,e)="sqrt(A,(p+A/p)/2,e)" 当|p*p-a|="">=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的递归算法。<br><strong><strong>**</strong></strong>/<br>float Sqrt(float A, float p, float e)<br>{   if(fabs(p<em>p-A)&lt;e)<br>      return p;<br>   else<br>      return Sqrt(A,(p+A/p)/2,e);<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】已知Ackerman函数的定义如下：<br>   akm(m,n) = n+1                 当m=0<br>   akm(m,n) = akm(m-1,1)          当m!=0,n=0<br>   akm(m,n) = akm(m-1,akm(m,n-1)) 当m!=0,n!=0<br>请写出递归算法。<br><strong><strong>**</strong></strong>/<br>int Akm(int m, int n)<br>/</em> 若 m<0或n<0则返回-1 *="" {="" if(m<0||n<0)="" return="" -1;="" if(m="=0)" n+1;="" else="" if(m!="0&&n==0)" akm(m-1,1);="" akm(m-1,akm(m,n-1))="" ;="" }="" **********="" 【题目】试写出求递归函数f(n)的非递归算法：="" f(n)="n+1" 当n="0">0<br><strong><strong>**</strong></strong>/<br>int F(int n)<br>/<em> 如果 n&lt;0则返回-1 </em>/<br>{   int i = n,count=1;<br>    if(n<0) return="" -1;="" else="" if(n="=0)" n+1;="" for(;i="">0;i=i/2)<br>         count = count<em>i ;<br>    return count;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p</em>p-A|<e sqrt(a,p,e)="sqrt(A,(p+A/p)/2,e)" 当|p*p-a|="">=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的非递归算法。<br><strong><strong>**</strong></strong>/<br>float Sqrt(float A, float p, float e)<br>{   float mp=p;<br>    if(fabs(p<em>p-A)&lt;e)<br>      return p;<br>      else<br>         while(fabs(mp</em>mp-A)&gt;=e)<br>         {<br>           mp=(mp+A/mp)/2 ;<br>         }<br>         return mp;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设以二维数组g[1..m][1..n]表示一个图像<br>区域，g[i][j]表示该区域中点(i,j)所具颜色，其值<br>为从0到k的整数。试编写递归算法，将点(i0,j0)所在<br>区域的颜色置换为颜色c。约定与(i0,j0)同色的上、<br>下、左、右的邻接点为同色区域的点。<br><br>表示图像区域的类型定义如下：<br>typedef char GTYPE[m+1][n+1];<br><strong><strong>**</strong></strong>/<br>void ChangeColor(GTYPE g, int m, int n,<br>                 char c, int i0, int j0)<br>/<em> 在g[1..m][1..n]中，将元素g[i0][j0] </em>/<br>/<em> 所在的同色区域的颜色置换为颜色c    </em>/<br>{<br>   if(i0&gt;m||j0&gt;n)//初次调用时下标不合法<br>     {<br>         return;<br>     }<br>     int color;<br>     color=g[i0][j0];<br>     g[i0][j0]=c;<br>     if(i0-1&gt;=1)//判断是否越界，下同<br>     {<br>         if(g[i0-1][j0]==color)<br>         {<br>             ChangeColor(g,m,n,c,i0-1,j0);<br>         }<br>     }<br>     if(i0+1&lt;=m)<br>     {<br>         if(g[i0+1][j0]==color)<br>         {<br>             ChangeColor(g,m,n,c,i0+1,j0);<br>         }<br>     }<br>     if(j0-1&gt;=1)<br>     {<br>         if(g[i0][j0-1]==color)<br>         {<br>             ChangeColor(g,m,n,c,i0,j0-1);<br>         }<br>     }<br>     if(j0+1&lt;=n)<br>     {<br>         if(g[i0][j0+1]==color)<br>         {<br>             ChangeColor(g,m,n,c,i0,j0+1);<br>         }<br>     }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】若两棵二叉树T1和T2皆为空，或者皆不空<br>且T1的左、右子树和T2的左、右子树分别相似，则<br>称二叉树T1和T2相似。试编写算法，判别给定两棵<br>二叉树是否相似。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>**</strong></strong>/<br>Status Similar(BiTree T1, BiTree T2)<br>/</em> 判断两棵二叉树是否相似的递归算法 <em>/<br>{   if(T1==null&amp;&amp;null==T2) return true;<br>    else if(T1&amp;&amp;T2){<br>      if(ERROR==  Similar(T1-&gt;lchild, T2-&gt;lchild))return ERROR;<br>      if(ERROR==  Similar(T1-&gt;rchild, T2-&gt;rchild))return ERROR;<br>    }else return ERROR;<br>     return true;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，求对二叉树T先序遍历时<br>第k个访问的结点的值。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  </em>lchild, <em>rchild;<br>} BiTNode, </em>BiTree;<br><strong><strong>**</strong></strong>/<br>TElemType PreOrderK(BiTree T, int k)<br>/<em> 求对二叉树T先序遍历时第k个访问的结点的值。</em>/<br>/<em> 若失败，则返回’#’                         </em>/<br>{<br><br>    int i=0,count=0;  //i为循环变量、count为记录根结点的左子树的结点个数<br>    TElemType d;      //定义一个返回值变量d<br>    BiTree a[20],b;   //a[20]记录左子树的根结点,b为一个中间变量<br>    if(k&lt;=0||!T) return ‘#’; //当k为0或者T空时，没有找到结点，返回’#’<br>    if(k==1) return T-&gt;data; //当k从给定的数减到1时，表示找到，返回bt-&gt;data<br>    d=PreOrderK(T-&gt;lchild,k-1); //左子树递归<br>    if(d!=’#’)  //当找到T时，返回T<br>        return(d);<br>    b=T-&gt;lchild; //没有找到，继续找<br>    while(b||i)   //下面是计算左子树有多少个结点的算法，并记录在count中<br>    {<br>        if(b)    //当左子树非空时，<br>        {<br>            a[i]=b;  //记录第i个结点在a[i]中，用来计算本结点的右子树用的<br>            i++;     //计算下一个结点的序号<br>            b=b-&gt;lchild;  //对下一个结点操作<br>            count++;      //记录结点数<br>            }<br>        else<br>        {<br>            i–;   //如果b空，表示执行到最左的叶子，现在要找到上一个结点的右子树<br>            b=a[i]; //把上一个结点赋给b<br>            b=b-&gt;rchild; //使b指向右子树<br>        }<br>    }<br>    d=PreOrderK(T-&gt;rchild,k-count-1); //递归右子树,并返回k-count-1，表示要找的结点可能在右子树的第k-count-1的位置<br>    if(d!=’#’)    //对T判断，当T不为’#’时，表示找到，返回T<br>        return (d);<br>    else         //否则返回 ‘#’表示没有找到<br>        return ‘#’;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，计算二叉树T中叶子结点的数目。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>**</strong></strong>/<br><br>int Leaves(BiTree T)<br>/</em> 计算二叉树T中叶子结点的数目<em>/<br>{ if(!T) return 0; /</em>空树没有叶子<em>/<br>  else if(!T-&gt;lchild&amp;&amp;!T-&gt;rchild) return 1; /</em>叶子结点<em>/<br>  else return Leaves(T-&gt;lchild)+Leaves(T-&gt;rchild);/</em>左子树的叶子数加上右子树的叶子数<em>/<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试利用栈及其基本操作写出二叉树T的非递归<br>的先序遍历算法。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  </em>lchild,<em>rchild;<br>} BiTNode, </em>BiTree;<br>可用栈类型Stack的相关定义：<br>typedef BiTree SElemType;   // 栈的元素类型<br>Status InitStack(Stack &amp;S);<br>Status StackEmpty(Stack S);<br>Status Push(Stack &amp;S, SElemType e);<br>Status Pop(Stack &amp;S, SElemType &amp;e);<br>Status GetTop(Stack S, SElemType &amp;e);<br><strong><strong>**</strong></strong>/<br><br>void PreOrder(BiTree T, void (<em>visit)(TElemType))<br>/</em> 使用栈，非递归先序遍历二叉树T，     <em>/<br>/</em> 对每个结点的元素域data调用函数visit <em>/<br>{   Stack s;<br>    InitStack(s);<br>    BiTree p = T;<br>    while(p){<br>      visit(p-&gt;data);<br>      if(p-&gt;rchild)<br>            Push(s,p-&gt;rchild);<br>      if(p-&gt;lchild)<br>            p = p-&gt;lchild;<br>       else<br>         if(StackEmpty(s)!=true) Pop(s, p);<br>         else<br>            p = null;<br>    }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试利用栈及其基本操作写出二叉树T的非递归<br>的后序遍历算法(提示：为分辨后序遍历时两次进栈的<br>不同返回点，需在指针进栈时同时将一个标志进栈）。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  </em>lchild,<em>rchild;<br>} BiTNode, </em>BiTree;<br>可用栈类型Stack的相关定义：<br>typedef struct {<br>  struct BiTNode <em>ptr; // 二叉树结点的指针类型<br>  int      tag; // 0..1<br>} SElemType;    // 栈的元素类型<br>Status InitStack(Stack &amp;S);<br>Status StackEmpty(Stack S);<br>Status Push(Stack &amp;S, SElemType e);<br>Status Pop(Stack &amp;S, SElemType &amp;e);<br>Status GetTop(Stack S, SElemType &amp;e);<br><strong><strong>**</strong></strong>/<br>void PostOrder(BiTree bt, void (</em>visit)(TElemType))<br>/<em> 使用栈，非递归后序遍历二叉树T，     </em>/<br>/<em> 对每个结点的元素域data调用函数visit </em>/<br>{<br>    Stack S;<br>    InitStack(S);<br>    SElemType e;<br>    BiTree p=bt;<br>    int tag=0;<br>    if(bt){<br>        e.tag=0;<br>        while(!StackEmpty(S)||p==bt){<br>            while(p&amp;&amp;!tag){<br>                e.ptr=p;<br>                if(p-&gt;lchild){//如果存在左子树<br>                p=p-&gt;lchild;<br>                e.tag=0;<br>                }<br>                else{//否则为右子树<br>                p=p-&gt;rchild;<br>                e.tag=1;<br>                }<br>            Push(S,e);<br>        }//while<br>        GetTop(S,e);<br>        if(!StackEmpty(S)&amp;&amp;e.tag){<br>            Pop(S,e); //叶子结点出栈<br>            p=e.ptr;<br>            visit(p-&gt;data);//输出该结点<br>        }<br>        if(!StackEmpty(S)){<br>            Pop(S,e); //得到上一层结点<br>            p=e.ptr;<br>            if(e.tag){//右子树已经入栈<br>                visit(p-&gt;data);<br>                p=NULL;<br>            }<br>            else{//右子树没入过栈<br>                if(p-&gt;rchild){<br>                    p=p-&gt;rchild;<br>                    tag=0;<br>                    e.tag=1;<br>                    Push(S,e);<br>                }<br>                else{//没有右子树<br>                    visit(p-&gt;data);<br>                    p=NULL;<br>                }<br>            }<br>        }<br>        else{//栈空则，p为NULL<br>            p=NULL;<br>        }<br>    }//while<br>  }//if<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】二叉树采用三叉链表的存储结构，试编写<br>不借助栈的非递归中序遍历算法。<br>三叉链表类型定义：<br>typedef struct TriTNode {<br>  TElemType data;<br>  struct TriTNode  <em>parent, </em>lchild, <em>rchild;<br>} TriTNode, </em>TriTree;<br><strong><strong>**</strong></strong>/<br>void InOrder(TriTree PT, void (<em>visit)(TElemType))<br>/</em> 不使用栈，非递归中序遍历二叉树PT，  <em>/<br>/</em> 对每个结点的元素域data调用函数visit <em>/<br>{<br>    TriTree p,pr;<br> if(PT!=NULL)<br> {<br>    p = PT;<br>    while(p!=NULL)<br>    { if(p-&gt;lchild==NULL) visit(p-&gt;data);<br>         //输出有右子树的结点<br>      if(p-&gt;lchild)  p = p-&gt;lchild;<br>      else<br>          if(p-&gt;rchild)  p = p-&gt;rchild;<br>          else<br>          {<br><br>           do{<br>                pr = p;<br>                p = p-&gt;parent;<br>                if(p-&gt;rchild!=pr)  //如果pr是p的右子树则不输出<br>                     visit(p-&gt;data);<br>              }while(p!=NULL&amp;&amp;(p-&gt;rchild==pr||NULL==p-&gt;rchild));<br>           if(p!=NULL)   p = p-&gt;rchild;<br>          }<br>    }<br> }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设在三叉链表的结点中增设一个标志域<br>(mark取值0,1或2)以区分在遍历过程中到达该结点<br>时应继续向左或向右或访问该结点。试以此存储结<br>构编写不用栈辅助的二叉树非递归后序遍历算法。<br>带标志域的三叉链表类型定义：<br>typedef struct TriTNode {<br>  TElemType  data;<br>  struct TriTNode  </em>lchild, <em>rchild, </em>parent;<br>  int       mark;  // 标志域<br>} TriTNode, <em>TriTree;<br><strong><strong>**</strong></strong>/<br>void PostOrder(TriTree T, void (</em>visit)(TElemType))<br>/<em> 不使用栈，非递归后序遍历二叉树T，   </em>/<br>/<em> 对每个结点的元素域data调用函数visit </em>/<br>{<br>     TriTree p,pr;<br> if(T!=NULL)<br> {<br>    p = T;<br>    while(p!=NULL)<br>    {<br>      if(p-&gt;lchild)  p = p-&gt;lchild;<br>      else<br>          if(p-&gt;rchild)  p = p-&gt;rchild;<br>          else<br>          {<br>           do{<br>             pr = p;<br>             visit(pr-&gt;data);<br>             p = p-&gt;parent;<br>           }while(p!=NULL&amp;&amp;(p-&gt;rchild==pr||NULL==p-&gt;rchild));<br>           if(p!=NULL)   p = p-&gt;rchild;<br>          }<br>    }<br> }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，将二叉树中所有结点的<br>左、右子树相互交换。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>**</strong></strong>/<br>void ExchangeSubTree(BiTree &amp;T)<br>/</em> 将二叉树中所有结点的左、右子树相互交换 <em>/<br>{    BiTree p;<br>    if(!T) return;<br>    if(T-&gt;lchild) ExchangeSubTree(T-&gt;lchild);<br>    if(T-&gt;rchild) ExchangeSubTree(T-&gt;rchild);<br>    p = T-&gt;lchild;<br>    T-&gt;lchild = T-&gt;rchild;<br>    T-&gt;rchild = p;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法：求二叉树中以元素值<br>为x的结点为根的子树的深度。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  </em>lchild, <em>rchild;<br>} BiTNode, </em>BiTree;<br><strong><strong>**</strong></strong>/<br>int BirTreeDepth(BiTree T){<br>  int depthLeft,depthRight;<br>  if(null==T) return 0;<br>  else {<br>    depthLeft = BirTreeDepth(T-&gt;lchild);<br>    depthRight = BirTreeDepth(T-&gt;rchild);<br>    return 1+(depthLeft &gt; depthRight?depthLeft:depthRight);<br>  }<br>}<br>int Findx(BiTree T,BiTree &amp;p,TElemType x){<br>if(T){<br>if(T-&gt;data==x){<br>p=T;<br>return 0;<br>}<br>else{<br>Findx(T-&gt;lchild,p,x);<br>Findx(T-&gt;rchild,p,x);<br>}<br>}<br>}<br><br>int Depthx(BiTree T, TElemType x)<br>/<em> 求二叉树中以值为x的结点为根的子树深度</em>/<br>{<br>    BiTree p=NULL;<br>Findx(T,p,x);<br>return BirTreeDepth(p);<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法：对于二叉树中每一个元素值为x<br>的结点，删去以它为根的子树，并释放相应的空间。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>**</strong></strong>/<br>void Destroy(BiTree &amp;T){<br> if(T){<br>    Destroy(T-&gt;lchild);<br>    Destroy(T-&gt;rchild);<br>    free(T);<br> }<br>}<br>/</em>BiTree find(BiTree &amp;T, char x){<br>   if(!T) return null;<br>   if(T-&gt;data == x) return T;<br>   find(T-&gt;lchild,x); find(T-&gt;rchild,x);<br>}       <em>/<br><br>void ReleaseX(BiTree &amp;T, char x)<br>/</em> 对于二叉树T中每一个元素值为x的结点，<em>/<br>/</em> 删去以它为根的子树，并释放相应的空间 <em>/<br>{<br>    if(!T) return ;<br>    if(T-&gt;data==x)<br>    Destroy(T);<br>    ReleaseX(T-&gt;lchild, x);<br>      ReleaseX(T-&gt;rchild, x);<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写复制一棵二叉树的递归算法。<br>二叉链表类型定义：<br>typedef char TElemType; // 设二叉树的元素为char类型<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  </em>lchild, <em>rchild;<br>} BiTNode, </em>BiTree;<br><strong><strong>**</strong></strong>/<br>void CopyBiTree(BiTree T, BiTree &amp;TT)<br>/<em> 递归复制二叉树T得到TT </em>/<br>{<br>    if(!T) return ;<br>     TT = (BiTree)malloc(sizeof(BiTNode));<br>     if(!TT) return ;<br>     TT-&gt;data = T-&gt;data;<br>     if(T-&gt;lchild) CopyBiTree(T-&gt;lchild,TT-&gt;lchild);<br>     if(T-&gt;rchild) CopyBiTree(T-&gt;rchild,TT-&gt;rchild);<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写算法判别给定二叉树是否为完全二叉树。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br>可用队列类型Queue的相关定义：<br>typedef BiTree QElemType; // 设队列元素为二叉树的指针类型<br>Status InitQueue(Queue &amp;Q);<br>Status EnQueue(Queue &amp;Q, QElemType e);<br>Status DeQueue(Queue &amp;Q, QElemType &amp;e);<br>Status GetHead(Queue Q, QElemType &amp;e);<br>Status QueueEmpty(Queue Q);<br><strong><strong>**</strong></strong>/<br><br>Status CompleteBiTree(BiTree bt)<br>/</em> 判别二叉树T是否为完全二叉树<em>/<br>{  Queue Q;<br>     QElemType p;<br>     int tag=0;<br>     EnQueue(Q,bt);<br>     while(!QueueEmpty(Q))<br>     {<br>       DeQueue(Q,p);<br>       if(!p) tag=1;       //如果到最后输出都为空，表示已经遍历完成，确认是完全树<br>       else if(tag) return ERROR;<br>       else<br>       {<br>       EnQueue(Q,p-&gt;lchild);<br>       EnQueue(Q,p-&gt;rchild);<br>       }<br>     }<br>     return OK;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试编写一个二叉排序树的判定算法。<br>二叉排序树的类型BSTree定义如下：<br>typedef struct {<br>  KeyType key;<br>  … …   // 其他数据域<br>} TElemType;<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BSTNode  </em>lchild, <em>rchild;<br>}BSTNode, </em>BSTree;<br><strong><strong>**</strong></strong>/<br>Status IsBSTree(BSTree t)<br>/<em> 判别二叉树T是否为二叉排序树。</em>/<br>/<em> 若是，则返回TRUE，否则FALSE  </em>/<br>{<br>    BSTree p,q;<br> if(t)<br>  {    p=t-&gt;lchild;<br>       q=t-&gt;rchild;<br>  if(p&amp;&amp;p-&gt;data.key&gt;=t-&gt;data.key)<br>    return FALSE;<br>  if(q&amp;&amp;q-&gt;data.key&lt;=t-&gt;data.key)<br>    return FALSE;<br><br>    if (IsBSTree(p))<br>     return IsBSTree(q);<br>     return FALSE;<br><br>  }<br>  return TRUE;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，从大到小输出给定二叉排序树<br>中所有关键字不小于x的数据元素。<br>二叉排序树的类型BSTree定义如下：<br>typedef struct {<br>    KeyType key;<br>    … …   // 其他数据域<br>} TElemType;<br>typedef struct BSTNode {<br>  TElemType  data;<br>  struct BSTNode  <em>lchild,</em>rchild;<br>}BSTNode, <em>BSTree;<br><strong><strong>**</strong></strong>/<br>void OrderOut(BSTree t, KeyType x, void(</em>visit)(TElemType))<br>/<em> 调用visit(T-&gt;data)输出  </em>/<br>{  KeyType key = t-&gt;data.key;<br><br>    if(!t)<br>    {<br>        return;<br>    }<br>    if(key&gt;=x)<br>    {<br>        OrderOut(t-&gt;rchild,x,visit);<br>        visit(t-&gt;data);<br>        OrderOut(t-&gt;lchild,x,visit);<br>    }<br>    else<br>    {<br>        OrderOut(t-&gt;rchild,x,visit);<br>    }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试写一非递归算法，在二叉查找树T中插入元素e。<br>二叉查找树的类型BSTree定义如下：<br>typedef struct {<br>  KeyType key;<br>    … …   // 其他数据域<br>} TElemType;<br>typedef struct BSTNode {<br>  TElemType data;<br>  struct BSTNode  <em>lchild,</em>rchild;<br>} BSTNode, <em>BSTree;<br><strong><strong>**</strong></strong>/<br>Status InsertBST_I(BSTree &amp;T, TElemType k)<br>/</em> 在二叉查找树T中插入元素e的非递归算法<em>/<br>{  BSTree p,L,q = T ;<br>  p = (BSTree)malloc(sizeof(BSTNode));<br>  if(p == NULL)   return FALSE;<br>  p-&gt;data = k;  p-&gt;lchild = NULL; p-&gt;rchild = NULL;<br>  while(q!=NULL)<br>  {<br>    if(q-&gt;data.key == k.key)   return FALSE;<br>    if(q-&gt;data.key &gt; k.key)<br>        {<br>         if(q-&gt;lchild!=NULL)    q = q-&gt;lchild;<br>          else                  q-&gt;lchild = p;<br>        }<br>    if(q-&gt;data.key &lt; k.key)<br>        {<br>         if(q-&gt;rchild!=NULL)    q = q-&gt;rchild;<br>          else                  q-&gt;rchild = p;<br>         }<br>  }<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，求二叉树T中结点a和b的最近共同祖先。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  </em>lchild,<em>rchild;<br>} BiTNode, </em>BiTree;<br>可用栈类型Stack的相关定义：<br>typedef struct {<br>  BiTNode <em>ptr; // 二叉树结点的指针类型<br>  int      tag; // 0..1<br>} SElemType;      // 栈的元素类型<br>Status InitStack(Stack &amp;S);<br>Status StackEmpty(Stack S);<br>int StackLength(SqStack S);<br>Status Push(Stack &amp;S, SElemType e);<br>Status Pop(Stack &amp;S, SElemType &amp;e);<br>Status GetTop(Stack S, SElemType &amp;e);<br><strong><strong>**</strong></strong>/<br> void findElem(BiTree T,TElemType e,Stack &amp;s)<br>{<br>    BiTree t=T;<br>    BiTNode </em>bip;<br>    SElemType se;<br>    while(t)<br>    {<br>        while(t-&gt;lchild)<br>        {<br>            if(t-&gt;data==e) return ;<br>            se.ptr=t;se.tag=1;<br>            Push(s,se);<br>            t=t-&gt;lchild;<br>        }<br>        if(t-&gt;data==e) return ;<br>        if(t-&gt;rchild) {se.ptr=t;se.tag=1;Push(s,se);t=t-&gt;rchild;}<br>        else<br>        {<br>            bip=t;Pop(s,se);t=se.ptr;<br>            while(t-&gt;rchild==bip||!t-&gt;rchild)<br>            {<br>                bip=t;<br>                if(t!=T) {Pop(s,se);t=se.ptr;}<br>                else return;<br>            }<br>            se.ptr=t;se.tag=1;<br>            Push(s,se);<br>            t=t-&gt;rchild;<br>        }<br>    }<br>}<br><br><br><br>BiTree CommAncestor(BiTree T, TElemType a, TElemType b)<br>/<em> 求二叉树T中结点a和b的最近共同祖先</em>/<br>{   Stack sa,sb,st;<br>    SElemType sea,seb;<br>    BiTree bi,bii;<br><br>    InitStack(sa);InitStack(sb);InitStack(st);<br>    findElem(T,a,sa);<br>    findElem(T,b,sb);<br><br>    while(!StackEmpty(sa))<br>    {<br>        Pop(sa,sea);<br>        bi=sea.ptr;<br>        st=sb;<br>        while(!StackEmpty(st))<br>        {<br>            Pop(st,seb);<br>            bii=seb.ptr;<br>            if(bi-&gt;data==bii-&gt;data)return bi;<br>        }<br>    }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】在二叉排序树的每个结点中增设一个lsize域，<br>其值为该结点的左子树中的结点数加1。试编写时间复杂<br>度为O(logn)的算法，求树中第k小的结点的位置。<br>二叉排序树的类型BSTree定义如下：<br>typedef char KeyType;<br><br>typedef struct BSTNode {<br>  KeyType key;<br>  struct BSTNode  <em>lchild,</em>rchild;<br>  int lsize; // 新增域，值为左子树的结点数+1<br>} BSTNode, <em>BSTree;<br><strong><strong>**</strong></strong>/<br><br><br>BSTNode </em>Ranking(BSTree T, int k)<br>/<em> 在含lsize域的二叉排序树T中，</em>/<br>/<em> 求指向T中第k小的结点的指针  </em>/<br>{  if(!T) return null;<br>    if(T-&gt;lsize==k) return T;<br>    else if(T-&gt;lsize&gt;k) return Ranking(T-&gt;lchild, k) ;<br>         else return Ranking(T-&gt;rchild, k-T-&gt;lsize);<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】假设二叉排序树T的每个结点的平衡因子域bf当前<br>均为0。试编写算法，求二叉排序树T的深度，并为每个结点<br>的bf域赋予正确的平衡因子值。<br>平衡二叉排序树的类型BBSTree定义如下：<br>typedef char KeyType;<br>typedef struct BBSTNode {<br>  KeyType key;<br>  int bf;    // 平衡因子<br>  struct BBSTNode  <em>lchild,</em>rchild;<br>} BBSTNode, <em>BBSTree;<br><strong><strong>**</strong></strong>/<br>/</em>int depth(BBSTree t){<br>     int l;<br>     int r;<br>     if(!t) return 0;<br>     else {<br>       l = depth(t-&gt;lchild);<br>       r = depth(t-&gt;rchild);<br>       return 1+(l&gt;r?l:r);<br>     }<br>}  <em>/<br><br>int Depth_BF(BBSTree T)<br>/</em> 求二叉排序树T的深度，并为每个结点<em>/<br>/</em> 的bf域赋予正确的平衡因子值。      <em>/<br>{   int l,r;<br>    if(!T) return 0;<br>    else {<br>     l = Depth_BF(T-&gt;lchild);<br>     r = Depth_BF(T-&gt;rchild);<br>     T-&gt;bf = l-r;<br>    return 1+(l&gt;r?l:r);<br>    }<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】编写平衡二叉排序树的右平衡处理算法。<br>平衡二叉排序树的类型BBSTree定义如下：<br>typedef char KeyType;<br>typedef struct BBSTNode {<br>  KeyType key;<br>  int  bf;    // 平衡因子<br>  struct BBSTNode  </em>lchild,<em>rchild;<br>} BBSTNode, </em>BBSTree;<br>可调用下列旋转调整操作：<br>void L_Rotate(BBSTree &amp;p); // 对最小失衡子树p做左旋调整<br>void R_Rotate(BBSTree &amp;p); // 对最小失衡子树p做右旋调整<br><strong><strong>**</strong></strong>/<br><br>void RightBalance(BBSTree &amp;T)<br>/<em> 实现对二叉树T的右平衡处理</em>/<br>{<br>    BBSTree lc,rd;<br>   rd = T-&gt;rchild;<br>   switch(rd-&gt;bf){<br>       case RH:<br>            T-&gt;bf = rd-&gt;bf = EH; L_Rotate(T); break;<br>       case LH:<br>            lc = rd-&gt;lchild;<br>            switch(lc-&gt;bf){<br>              case LH: T-&gt;bf = EH;  lc-&gt;bf = EH; break;<br>              case EH: T-&gt;bf = rd-&gt;bf = EH;break;<br>              case RH: T-&gt;bf=LH; lc-&gt;bf = EH; break;<br>            }<br>           lc-&gt;bf=EH;<br>           R_Rotate(T-&gt;rchild);<br>           L_Rotate(T);<br>           break;<br>   }<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，对一棵以孩子兄弟链表表示<br>的树统计叶子的个数。<br>孩子兄弟链表类型定义：<br>typedef struct CSTNode {<br>  TElemType  data;<br>  struct CSTNode  <em>firstChild, </em>nextSibling;<br>} CSTNode, <em>CSTree;<br><strong><strong>**</strong></strong>/<br>void Count(CSTree T, int &amp;n){<br>   if(T){<br>     if(!T-&gt;firstChild) n++;<br>     Count(T-&gt;firstChild, n);<br>     Count(T-&gt;nextSibling, n);<br>   }<br>}<br><br>int Leave(CSTree T) /</em> 统计树T的叶子数<em>/<br>{<br>    int n =0;<br>    Count(T , n);<br>    return n;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，求一棵以孩子兄弟链表表示的树的度。<br>孩子兄弟链表类型定义：<br>typedef struct CSTNode {<br>  TElemType  data;<br>  struct CSTNode  </em>firstChild, <em>nextSibling;<br>} CSTNode, </em>CSTree;<br><strong><strong>**</strong></strong>/<br><br>int Degree(CSTree T) /<em> 求树T的度</em>/<br>{<br>   int ds,dt,d;<br>   CSTree p;<br>   if(!T) return 0;<br>   else { ds=0;dt=0;<br>       for( p = T-&gt;firstChild; p ; p= p-&gt;nextSibling){<br>          dt++;<br>          d= Degree(p);<br>          if(d&gt;ds) ds =d;<br>       }<br><br>       return ds&gt;dt?ds:dt;<br>   }<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，对以双亲表示法存储的树计算深度。<br>typedef struct {<br>  TElemType data;<br>  int     parent;  // 双亲位置<br>} PTNode; // 结点类型<br>typedef struct {<br>  PTNode nodes[MAX_TREE_SIZE]; // 结点存储空间<br>  int  n, r; // 结点数和根的位置<br>} PTree;<br><strong><strong>**</strong></strong>/<br>int PTreeDepth(PTree T) /<em> 求树T的深度</em>/<br>{<br> int maxdep = 0,i,dep,j;<br> for(i=0; i<t.n;i++){ dep="0;" for(j="i;" j="">0; j=T.nodes[j].parent) dep++;<br>      if(dep&gt;maxdep) maxdep = dep;<br> }<br>  return maxdep+1;<br><br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，对以双亲孩子表示法存储的树计算深度。<br>孩子链表类型定义：<br>typedef struct ChildNode {  // 孩子结点<br>  int childIndex;<br>  struct ChildNode <em>nextChild;<br>} ChildNode; // 孩子结点类型<br>typedef struct  {<br>  TElemType data;<br>  int     parent;  // 双亲位置<br>  struct ChildNode </em>firstChild; // 孩子链表头指针<br>} PCTreeNode; // 结点类型<br>typedef struct {<br>  PCTreeNode <em>nodes; // 结点存储空间<br>  int  n, r; // 结点数和根的位置<br>} PCTree;<br><strong><strong>**</strong></strong>/<br><br> int fun(PCTree T, int pos)<br>{<br>   if(T.nodes[pos].firstChild == NULL)  return 1;<br>   ChildNode </em>temp = T.nodes[pos].firstChild;<br>   int depth = 1, max = 1;<br><br>   while(temp != NULL)<br>   {<br>      if( T.nodes[temp-&gt;childIndex].firstChild != NULL)<br>      {<br>        depth = fun(T, temp-&gt;childIndex);<br>        if(depth &gt; max)<br>        max = depth;<br>      }<br>      temp = temp-&gt;nextChild;<br>   }<br><br>   return max + 1;<br><br>}<br>int PCTreeDepth(PCTree T) /<em> 求树T的深度</em>/<br>{<br>    int depth;<br>   depth = fun(T, T.r);<br>   return depth;<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试编写算法，对以孩子-兄弟链表表示的树计算深度。<br>孩子兄弟链表类型定义：<br>typedef struct CSTNode {<br>  TElemType  data;<br>  struct CSTNode  <em>firstChild, </em>nextSibling;<br>} CSTNode, <em>CSTree;<br><strong><strong>**</strong></strong>/<br>int TreeDepth(CSTree T)<br>/</em> 求树T的深度<em>/<br>{<br>     int dep1,dep2,dep;<br>     if(!T) dep=0;<br>     else{<br>        dep1 =   TreeDepth(T-&gt;firstChild);<br>        dep2 = TreeDepth(T-&gt;nextSibling);<br>        dep = dep1+1&gt;dep2?dep1+1:dep2;<br>     }<br>     return dep;<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】已知一棵树的由根至叶子结点按层次输出的<br>结点序列及每个结点的度。试编写算法，构造此树的<br>孩子兄弟链表。<br>孩子兄弟链表类型定义：<br>typedef struct CSTNode {<br>  TElemType  data;<br>  struct CSTNode  </em>firstChild, <em>nextSibling;<br>} CSTNode, </em>CSTree;<br><strong><strong>**</strong></strong>/<br>CSTree CreateCSTNode(char e) {<br>    CSTNode <em>p = NULL;<br>    p = (CSTNode</em>)malloc(sizeof(CSTNode));<br>    p-&gt;data = e;<br>    p-&gt;firstChild = NULL;<br>    p-&gt;nextSibling = NULL;<br>    return p;<br>}<br><br><br>void BuildCSTree(CSTree &amp;T, char <em>node, int </em>degree)<br>/<em> 由结点的层序序列node和各结点的度degree构造树的孩子兄弟链表T </em>/<br>{<br>    int i, j, present=1;<br>    CSTree Tree[50];<br><br>    if(NULL == node) {<br>        return;<br>    }<br>    Tree[0] = CreateCSTNode(node[0]);<br>    T = Tree[0];<br>    for(i=0; node[i]!=’\0’; i++) {<br>        if(degree[i]!=0) {<br>            Tree[present] = CreateCSTNode(node[present]);<br>            Tree[i]-&gt;firstChild = Tree[present];<br>            present ++;<br>            for(j=2; j&lt;=degree[i]; j++) {<br>                Tree[present] = CreateCSTNode(node[present]);<br>                Tree[present-1]-&gt;nextSibling = Tree[present];<br>                present ++;<br>            }<br>        }<br>    }<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】试编写非递归算法，实现并查集带路径压缩的<br>查找操作。<br>并查集的类型定义如下：<br>typedef struct {<br>  int <em>parent;<br>  int  n;<br>} MFSet;<br><strong><strong>**</strong></strong>/<br>int find(MFSet S, int i)<br>/</em> 并查集带路径压缩的查找的非递归实现 <em>/<br>{   if(i<0||i>=S.n) return -1;<br>    if(S.parent[i]&lt;0) return i;<br>    S.parent[i] = find(S,S.parent[i]);<br>     return S.parent[i];<br>}<br><br><br>/<strong><strong>**</strong></strong><br>【题目】编写算法，创建有向图的邻接数组存储结构。<br>图的邻接数组存储结构的类型定义如下：<br>#define UNVISITED  0<br>#define VISITED    1<br>#define MAX_VEX_NUM  4<br>#define INFINITY MAXINT // 计算机允许的整数最大值，即∞<br>typedef int VRType;<br>typedef char InfoType;<br>typedef char VexType;<br>typedef enum {DG,DN,UDG,UDN} GraphKind; // 有向图,有向网,无向图,无向网<br>typedef struct {<br>    VRType adj; // 顶点关系类型。对无权图，用1(是)或0(否)表示相邻否；<br>                // 对带权图，则为权值类型<br>    InfoType </0||i></em>info; // 该弧相关信息的指针(可无)<br>}ArcCell;//,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];<br>typedef struct {<br>  ArcCell arcs[MAX_VEX_NUM][MAX_VEX_NUM]; // 关系数组<br>  VexType vexs[MAX_VEX_NUM]; // 顶点数组<br>  int n, e;   // 顶点数和边（弧）数<br>  GraphKind kind; // 图的类型<br>} MGraph; // 邻接数组类型<br>typedef struct {<br>  VexType v, w;<br>  int inf;<br>} ArcInfo;<br>可调用以下基本操作：<br>Status InitGraph(MGraph &amp;G, GraphKind kind, int n);<br>  // 初始化含n个顶点空间的kind类的空图G<br>int LocateVex(MGraph G, VexType v); // 查找顶点v在图G中的位序<br><strong><strong>**</strong></strong>/<br>Status CreateDG(MGraph &amp;G, VexType <em>vexs, int n,<br>                           ArcInfo </em>arcs, int e)<br>/<em> 创建含n个顶点和e条边的有向图G，vexs为顶点信息，arcs为边信息</em>/<br>{  int i,j,k;<br>    VexType v,w;<br>    if((OVERFLOW==InitGraph(G, G.kind, n))) return ERROR;<br>    G.n = n;G.e = e;<br>    for(i = 0; i<g.n; 0="" 1="" 4="" i++)="" g.vexs[i]="vexs[i];" for(k="0;" k<g.e;="" k++){="" v="arcs[k].v;" w="arcs[k].w;" i="LocateVex(G," v);="" j="LocateVex(G," w);="" if(i<0="" ||="" j<0)="" return="" error;="" g.arcs[i][j].adj="1;" }="" ok;="" **********="" 【题目】编写算法，在图g中，相对于k顶点的当前="" 邻接顶点m顶点，求下一个邻接顶点。="" 图的邻接数组存储结构的类型定义如下：="" #define="" unvisited="" visited="" max_vex_num="" infinity="" maxint="" 计算机允许的整数最大值，即∞="" typedef="" int="" vrtype;="" char="" infotype;="" vextype;="" enum="" {dg,dn,udg,udn}="" graphkind;="" 有向图,有向网,无向图,无向网="" struct="" {="" vrtype="" adj;="" 顶点关系类型。对无权图，用1(是)或0(否)表示相邻否；="" 对带权图，则为权值类型="" infotype="" *info;="" 该弧相关信息的指针(可无)="" }arccell;="" ,adjmatrix[max_vertex_num][max_vertex_num];="" arccell="" arcs[max_vex_num][max_vex_num];="" 关系数组="" vextype="" vexs[max_vex_num];="" 顶点数组="" n,="" e;="" 顶点数和边（弧）数="" graphkind="" kind;="" 图的类型="" mgraph;="" 邻接数组类型="" nextadjvex(mgraph="" g,="" k,="" m)="" *="" 在图g中，相对于k顶点的当前邻接顶点m顶点，求下一个邻接顶点*="" i;="" if(k="=0&&m==0)" 0;="" for(="" i<g.n;="" +1="" if(g.arcs[k][i].adj)="" if(i="=" (g.n-1))="" -1;="" 【题目】编写算法，在图g中置顶点v到顶点w的弧或边。="" 可调用以下基本操作：="" locatevex(mgraph="" 查找顶点v在图g中的位序="" status="" setarc(mgraph="" &g,="" v,="" w,="" info)="" 在图g中置顶点v到顶点w的弧或边*="" i,j;="" <="" j)="" if(g.arcs[i][j].adj="=" 1)="" true;="" else{="" g.arcs[i][j].info="info.info;" g.e="" +="1;" 【题目】编写算法，计算以邻接表方式存储的有向图g中k顶点的出度。="" 图的邻接表存储结构的类型定义如下：="" adjvexnode="" adjvex;="" 邻接顶点在顶点数组中的位序="" *next;="" 指向下一个邻接顶点（下一条边或弧）="" info;="" 存储边（弧）相关信息，对于非带权图可不用="" adjvexnode,="" *adjvexnodep;="" 邻接链表的结点类型="" vexnode="" data;="" 顶点值，vextype是顶点类型，由用户定义="" *firstarc;="" 邻接链表的头指针="" vexnode;="" 顶点数组的元素类型="" *vexs;="" 顶点数组，用于存储顶点信息="" *tags;="" 标志数组="" algraph;="" 邻接表类型="" outdegree(algraph="" k)="" 求有向图g中k顶点的出度。若k顶点不存在，则返回-1="" i,j="0;" adjvexnodep="" p;="" if(k<0||k="">=G.n)    return -1;<br> if(G.vexs[k].firstArc != NULL)<br>    p = G.vexs[k].firstArc;<br> for( ; p!=NULL;p = p-&gt;next)<br>   {<br>     j++;<br>   }<br>   return j;<br><br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写算法，计算以邻接表方式存储的有向图G中<br>k顶点的入度。<br>图的邻接表存储结构的类型定义如下：<br>#define UNVISITED  0<br>#define VISITED    1<br>#define INFINITY MAXINT // 计算机允许的整数最大值，即∞<br>typedef char VexType;<br>typedef enum {DG,DN,UDG,UDN} GraphKind; // 有向图,有向网,无向图,无向网<br>typedef struct AdjVexNode {<br>  int adjvex;  // 邻接顶点在顶点数组中的位序<br>  struct AdjVexNode <em>next; // 指向下一个邻接顶点（下一条边或弧）<br>  int info;    // 存储边（弧）相关信息，对于非带权图可不用<br>} AdjVexNode, </em>AdjVexNodeP; // 邻接链表的结点类型<br>typedef struct VexNode {<br>  VexType data;    // 顶点值，VexType是顶点类型，由用户定义<br>  struct AdjVexNode <em>firstArc; // 邻接链表的头指针<br>} VexNode; // 顶点数组的元素类型<br>typedef struct {<br>  VexNode </em>vexs;  // 顶点数组，用于存储顶点信息<br>  int n, e;       // 顶点数和边（弧）数<br>  GraphKind kind; // 图的类型<br>  int <em>tags;      // 标志数组<br>} ALGraph;  // 邻接表类型<br><strong><strong>**</strong></strong>/<br>int inDegree(ALGraph G, int k)<br>/</em> 求有向图G中k顶点的入度。若k顶点不存在，则返回-1 <em>/<br>{<br>    int i ,j;<br>  AdjVexNodeP p;<br>  if(k<0||k>=G.n)  return -1;<br>  for(i = 0,j=0;i<g.n;i++) {="" if(g.vexs[i].firstarc="" !="NULL)" p="G.vexs[i].firstArc;" for(="" ;="" p!="NULL;p" =="" p-="">next)<br>         if(p-&gt;adjvex == k)<br>             j++;<br>   }<br>  }<br>  return j;<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写算法，创建有向图的邻接表存储结构。<br>图的邻接表存储结构的类型定义如下：<br>#define UNVISITED  0<br>#define VISITED    1<br>#define MAX_VEX_NUM  4<br>#define INFINITY MAXINT // 计算机允许的整数最大值，即∞<br>typedef char VexType;<br>typedef enum {DG,DN,UDG,UDN} GraphKind; // 有向图,有向网,无向图,无向网<br>typedef struct AdjVexNode {<br>  int adjvex;  // 邻接顶点在顶点数组中的位序<br>  struct AdjVexNode </g.n;i++)></0||k></em>next; // 指向下一个邻接顶点（下一条边或弧）<br>  int info;    // 存储边（弧）相关信息，对于非带权图可不用<br>} AdjVexNode, <em>AdjVexNodeP; // 邻接链表的结点类型<br>typedef struct VexNode {<br>  VexType data;    // 顶点值，VexType是顶点类型，由用户定义<br>  struct AdjVexNode </em>firstArc; // 邻接链表的头指针<br>} VexNode; // 顶点数组的元素类型<br>typedef struct {<br>  VexNode vexs[MAX_VEX_NUM];  // 顶点数组，用于存储顶点信息<br>  int n, e;       // 顶点数和边（弧）数<br>  GraphKind kind; // 图的类型<br>  int <em>tags;      // 标志数组<br>} ALGraph;  // 邻接表类型<br><br>可调用以下基本操作：<br>int LocateVex(ALGraph G, VexType v); // 查找顶点v在图G中的位序<br><strong><strong>**</strong></strong>/<br>Status CreateDG(ALGraph &amp;G, VexType </em>vexs, int n,<br>                            ArcInfo <em>arcs, int e)<br>/</em> 创建含n个顶点和e条边的有向图G，vexs为顶点信息，arcs为边信息<em>/<br>{<br>    int i,j,k;<br>   VexType v,w;<br>   AdjVexNodeP p;<br>   G.n = n; G.e = e;<br>  // G.vexs = (VexNode</em>)malloc(sizeof(VexNode)<em>n);<br>   G.tags = (int</em>)malloc(sizeof(int)<em>n);<br>   for(i = 0;i&lt;G.n;i++)<br>    {<br>      G.tags[i] = UNVISITED;<br>      G.vexs[i].data = vexs[i];<br>      G.vexs[i].firstArc = NULL;<br>    }<br>   for(k = 0;k&lt;G.e;k++)<br>   {<br>     v = arcs[k].v;  w=arcs[k].w;<br>     i = LocateVex(G,v);    j = LocateVex(G,w);<br>     if(i&lt;0||j&lt;0) return ERROR;<br><br>     p = (AdjVexNode</em>)malloc(sizeof(AdjVexNode));<br>     if(NULL == p)  return ERROR;<br>     p-&gt;adjvex = j;<br>     p-&gt;next = G.vexs[i].firstArc;<br>     G.vexs[i].firstArc = p;<br><br>   }<br>}<br><br>/<strong><strong>**</strong></strong><br>【题目】编写算法，创建无向图的邻接表存储结构。<br>图的邻接表存储结构的类型定义如下：<br>#define UNVISITED  0<br>#define VISITED    1<br>#define MAX_VEX_NUM  4<br>#define INFINITY MAXINT // 计算机允许的整数最大值，即∞<br>typedef char VexType;<br>typedef enum {DG,DN,UDG,UDN} GraphKind; // 有向图,有向网,无向图,无向网<br>typedef struct AdjVexNode {<br>  int adjvex;  // 邻接顶点在顶点数组中的位序<br>  struct AdjVexNode <em>next; // 指向下一个邻接顶点（下一条边或弧）<br>  int info;    // 存储边（弧）相关信息，对于非带权图可不用<br>} AdjVexNode, </em>AdjVexNodeP; // 邻接链表的结点类型<br>typedef struct VexNode {<br>  VexType data;    // 顶点值，VexType是顶点类型，由用户定义<br>  struct AdjVexNode <em>firstArc; // 邻接链表的头指针<br>} VexNode; // 顶点数组的元素类型<br>typedef struct {<br>  VexNode vexs[MAX_VEX_NUM]; //</em>vexs; 顶点数组，用于存储顶点信息<br>  int n, e;       // 顶点数和边（弧）数<br>  GraphKind kind; // 图的类型<br>  int <em>tags;      // 标志数组<br>} ALGraph;  // 邻接表类型<br><br>可调用以下基本操作：<br>int LocateVex(ALGraph G, VexType v); // 查找顶点v在图G中的位序<br><strong><strong>**</strong></strong>/<br>Status CreateUDG(ALGraph &amp;G, VexType </em>vexs, int n,<br>                            ArcInfo <em>arcs, int e)<br>/</em> 创建含n个顶点和e条边的无向图G，vexs为顶点信息，arcs为边信息<em>/<br>{<br>   int i,j,k;<br>   VexType v,w;<br>   AdjVexNodeP p,q;<br>   G.n = n; G.e = e;<br>  // G.vexs = (VexNode</em>)malloc(sizeof(VexNode)<em>n);<br>   G.tags = (int</em>)malloc(sizeof(int)<em>n);<br>   for(i = 0;i&lt;G.n;i++)<br>    {<br>      G.tags[i] = UNVISITED;<br>      G.vexs[i].data = vexs[i];<br>      G.vexs[i].firstArc = NULL;<br>    }<br>   for(k = 0;k&lt;G.e;k++)<br>   {<br>     v = arcs[k].v;  w=arcs[k].w;<br>     i = LocateVex(G,v);    j = LocateVex(G,w);<br>     if(i&lt;0||j&lt;0) return ERROR;<br>     p = (AdjVexNode</em>)malloc(sizeof(AdjVexNode));<br>     if(NULL == p)  return ERROR;<br>     p-&gt;adjvex = j;<br>     p-&gt;next = G.vexs[i].firstArc;<br>     G.vexs[i].firstArc = p;<br><br><br>      q = (AdjVexNode*)malloc(sizeof(AdjVexNode));<br>     if(NULL == q)  return ERROR;<br>     q-&gt;adjvex = i;<br>     q-&gt;next = G.vexs[j].firstArc;<br>     G.vexs[j].firstArc = q;<br>   }<br>}<br></g.n;></t.n;i++){></e></0)></0或n<0则返回-1></e></0则返回-1></0或n<0则返回-1></ht.size;i++){></i)></i)></p.length;></5;j++)></b)></html>
        </div>
        <div class="post-reply">
            
            
        </div>
    </div>
</section>
<script>
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>
      </div>
  </div>
  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Theme by <a href="http://haojen.github.io/">Haojen Ma</a>
        <br>
        Copyright © Codegitz 2018
        <br>
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>